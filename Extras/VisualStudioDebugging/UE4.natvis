<?xml version="1.0" encoding="utf-8"?>
<AutoVisualizer xmlns="http://schemas.microsoft.com/vstudio/debugger/natvis/2010">

  <!-- Epic Games, Inc. UE4 Visualizers -->
  
  <!-- FString visualizer -->
  <Type Name="FString">
    <DisplayString Condition="Data.ArrayNum == 0">Empty</DisplayString>
    <DisplayString Condition="Data.ArrayNum &lt; 0">Invalid</DisplayString>
    <DisplayString Condition="Data.ArrayMax &lt; Data.ArrayNum">Invalid</DisplayString>
    <DisplayString Condition="Data.ArrayMax &gt;= Data.ArrayNum">{Data.AllocatorInstance.Data,su}</DisplayString>
    <StringView Condition="Data.ArrayMax &gt;= Data.ArrayNum">Data.AllocatorInstance.Data,su</StringView>
  </Type>

  <!-- TStringView default visualizer -->
  <Type Name="TStringView&lt;*&gt;">
    <DisplayString Condition="Size == 0">Empty</DisplayString>
    <DisplayString Condition="Size &lt; 0">Invalid</DisplayString>
    <DisplayString Condition="Size &gt; 0">{DataPtr,[Size]}</DisplayString>
    <StringView Condition="Size &gt; 0">DataPtr,[Size]</StringView>
  </Type>

  <!-- TStringView<WIDECHAR> visualizer -->
  <Type Name="TStringView&lt;WIDECHAR&gt;">
    <DisplayString Condition="Size == 0">Empty</DisplayString>
    <DisplayString Condition="Size &lt; 0">Invalid</DisplayString>
    <DisplayString Condition="Size &gt; 0">{DataPtr,[Size]su}</DisplayString>
    <StringView Condition="Size &gt; 0">DataPtr,[Size]su</StringView>
  </Type>

  <!-- TStringView<ANSICHAR> visualizer -->
  <Type Name="TStringView&lt;ANSICHAR&gt;">
    <DisplayString Condition="Size == 0">Empty</DisplayString>
    <DisplayString Condition="Size &lt; 0">Invalid</DisplayString>
    <DisplayString Condition="Size &gt; 0">{DataPtr,[Size]s}</DisplayString>
    <StringView Condition="Size &gt; 0">DataPtr,[Size]s</StringView>
  </Type>

  <Type Name="TStringBuilderBase&lt;*&gt;">
    <DisplayString Condition="Base == CurPos">Empty</DisplayString>
    <DisplayString Condition="sizeof($T1) == 1">{Base,[CurPos-Base]s}</DisplayString>
    <DisplayString>{Base,[CurPos-Base]su}</DisplayString>
    <StringView Condition="sizeof($T1) == 1">Base,[CurPos-Base]s</StringView>
    <StringView>Base,[CurPos-Base]su</StringView>
  </Type>

  <Type Name="FGuid">
    <DisplayString>{{{A,Xb}-{(unsigned __int16)(B >> 16),Xb}-{(unsigned __int16)B,Xb}-{(unsigned __int16)(C >> 16),Xb}-{(unsigned __int16)C,Xb}{D,Xb}}}</DisplayString>
    <Expand>
      <Item Name="A">A,X</Item>
      <Item Name="B">B,X</Item>
      <Item Name="C">C,X</Item>
      <Item Name="D">D,X</Item>
    </Expand>
  </Type>

  <!-- FText visualizer -->
  <Type Name="FStringTableEntry">
    <DisplayString>{*DisplayString.Object}</DisplayString>
  </Type>
  <Type Name="FTextHistory_StringTableEntry::FStringTableReferenceData">
    <DisplayString Condition="StringTableEntry.Object != 0 &amp;&amp; StringTableEntry.WeakReferenceCount.ReferenceController->SharedReferenceCount &gt; 0">{*StringTableEntry.Object}</DisplayString>
    <DisplayString Condition="StringTableEntry.Object == 0 || StringTableEntry.WeakReferenceCount.ReferenceController->SharedReferenceCount == 0">&lt;MISSING STRING TABLE ENTRY&gt;</DisplayString>
  </Type>
  <Type Name="FTextHistory_StringTableEntry">
    <DisplayString>{*StringTableReferenceData.Object}</DisplayString>
  </Type>
  <Type Name="TLocalizedTextData&lt;*&gt;">
    <DisplayString>{*LocalizedString.Object}</DisplayString>
  </Type>
  <Type Name="TGeneratedTextData&lt;*&gt;">
    <DisplayString Condition="LocalizedString.Object">{*LocalizedString.Object}</DisplayString>
    <DisplayString Condition="!LocalizedString.Object">{DisplayString}</DisplayString>
  </Type>
  <Type Name="TIndirectTextData&lt;*&gt;">
    <DisplayString>{History}</DisplayString>
  </Type>
  <Type Name="FText">
    <DisplayString>{*TextData.Object}</DisplayString>
  </Type>

  <!-- FName visualizer -->

  <Type Name="FName">
    <DisplayString Condition="Number">{ComparisonIndex}_{Number - 1}</DisplayString>
    <DisplayString>{ComparisonIndex}</DisplayString>
  </Type>

  <Type Name="FName" Priority="High">
    <DisplayString Condition="Number">{DisplayIndex}_{Number - 1}</DisplayString>
    <DisplayString>{DisplayIndex}</DisplayString>
  </Type>

  <Type Name="FMinimalName">
    <DisplayString Condition="Number">{Index}_{Number - 1}</DisplayString>
    <DisplayString>{Index}</DisplayString>
  </Type>

  <Type Name="FNameEntryId">
    <DisplayString Condition="Value &amp; FNameDebugVisualizer::UnusedMask">Illegal name (block index out of range)</DisplayString>
    <DisplayString Condition="!GNameBlocksDebug[Value &gt;&gt; FNameDebugVisualizer::OffsetBits]">Illegal name (null block)</DisplayString>

    <DisplayString>{(FNameEntry&amp;)GNameBlocksDebug[Value &gt;&gt; FNameDebugVisualizer::OffsetBits][FNameDebugVisualizer::EntryStride * (Value &amp; FNameDebugVisualizer::OffsetMask)],sb}</DisplayString>
  </Type>

  <Type Name="FNameEntry">
    <DisplayString Condition="Header.Len &gt; FNameDebugVisualizer::MaxLength">Illegal name (length > NAME_SIZE)</DisplayString>
    <DisplayString Condition="Header.bIsWide">{WideName,[Header.Len]su}</DisplayString>
    <DisplayString>{AnsiName,[Header.Len]s}</DisplayString>
  </Type>

  <!-- FStatNameAndInfo -->
  <Type Name="FStatNameAndInfo">
    <DisplayString>{(EStatOperation::Type)((NameAndInfo.Number >> (EStatAllFields::StartShift + EStatOperation::Shift)) &amp; EStatOperation::Mask),en} {(EStatDataType::Type)((NameAndInfo.Number >> (EStatAllFields::StartShift + EStatDataType::Shift)) &amp; EStatDataType::Mask),en} {NameAndInfo}</DisplayString>
    <Expand>
      <Item Name="[Name]">NameAndInfo</Item>
      <Item Name="[StatOperation]">(EStatOperation::Type)((NameAndInfo.Number >> (EStatAllFields::StartShift + EStatOperation::Shift)) &amp; EStatOperation::Mask)</Item>
      <Item Name="[StatDataType]">(EStatDataType::Type)((NameAndInfo.Number >> (EStatAllFields::StartShift + EStatDataType::Shift)) &amp; EStatDataType::Mask)</Item>
      <Item Name="[IsCycle]">((NameAndInfo.Number >> (EStatAllFields::StartShift + EStatMetaFlags::Shift)) &amp; EStatMetaFlags::IsCycle) == EStatMetaFlags::IsCycle</Item>
      <Item Name="[IsMemory]">((NameAndInfo.Number >> (EStatAllFields::StartShift + EStatMetaFlags::Shift)) &amp; EStatMetaFlags::IsMemory) == EStatMetaFlags::IsMemory</Item>
      <Item Name="[IsPackedCCAndDuration]">((NameAndInfo.Number >> (EStatAllFields::StartShift + EStatMetaFlags::Shift)) &amp; EStatMetaFlags::IsPackedCCAndDuration) == EStatMetaFlags::IsPackedCCAndDuration</Item>
      <Item Name="[ShouldClearEveryFrame]">((NameAndInfo.Number >> (EStatAllFields::StartShift + EStatMetaFlags::Shift)) &amp; EStatMetaFlags::ShouldClearEveryFrame) == EStatMetaFlags::ShouldClearEveryFrame</Item>
    </Expand>
  </Type>

  <!-- FStatMessage without DebugStatData-->
  <Type Name="FStatMessage">
    <DisplayString>{NameAndInfo}</DisplayString>
  </Type>

  <!-- FStatMessage with DebugStatData -->
  <Type Name="FStatMessage" Priority="High">
    <!--ST_None	-->
    <DisplayString Condition="(EStatDataType::Type)((NameAndInfo.NameAndInfo.Number >> (EStatAllFields::StartShift + EStatDataType::Shift)) &amp; EStatDataType::Mask) == EStatDataType::ST_None">
      {{NoneType NameAndInfo={NameAndInfo}}}
    </DisplayString>

    <!--ST_int64 && !IsPackedCCAndDuration && !IsCycle -->
    <DisplayString Condition="(EStatDataType::Type)((NameAndInfo.NameAndInfo.Number >> (EStatAllFields::StartShift + EStatDataType::Shift)) &amp; EStatDataType::Mask) == EStatDataType::ST_int64 &amp;&amp; ((NameAndInfo.NameAndInfo.Number >> (EStatAllFields::StartShift + EStatMetaFlags::Shift)) &amp; EStatMetaFlags::IsPackedCCAndDuration) != EStatMetaFlags::IsPackedCCAndDuration &amp;&amp; ((NameAndInfo.NameAndInfo.Number >> (EStatAllFields::StartShift + EStatMetaFlags::Shift)) &amp; EStatMetaFlags::IsCycle) != EStatMetaFlags::IsCycle">
      {{Int64={DebugStatData.Cycles} NameAndInfo={NameAndInfo}}}
    </DisplayString>

    <!--ST_int64 && !IsPackedCCAndDuration && IsCycle -->
    <DisplayString Condition="(EStatDataType::Type)((NameAndInfo.NameAndInfo.Number >> (EStatAllFields::StartShift + EStatDataType::Shift)) &amp; EStatDataType::Mask) == EStatDataType::ST_int64 &amp;&amp; ((NameAndInfo.NameAndInfo.Number >> (EStatAllFields::StartShift + EStatMetaFlags::Shift)) &amp; EStatMetaFlags::IsPackedCCAndDuration) != EStatMetaFlags::IsPackedCCAndDuration &amp;&amp; ((NameAndInfo.NameAndInfo.Number >> (EStatAllFields::StartShift + EStatMetaFlags::Shift)) &amp; EStatMetaFlags::IsCycle) == EStatMetaFlags::IsCycle">
      {{Cycles={DebugStatData.Cycles} NameAndInfo={NameAndInfo}}}
    </DisplayString>

    <!--ST_int64 && IsPackedCCAndDuration && IsCycle -->
    <DisplayString Condition="(EStatDataType::Type)((NameAndInfo.NameAndInfo.Number >> (EStatAllFields::StartShift + EStatDataType::Shift)) &amp; EStatDataType::Mask) == EStatDataType::ST_int64 &amp;&amp; ((NameAndInfo.NameAndInfo.Number >> (EStatAllFields::StartShift + EStatMetaFlags::Shift)) &amp; EStatMetaFlags::IsPackedCCAndDuration) == EStatMetaFlags::IsPackedCCAndDuration &amp;&amp; ((NameAndInfo.NameAndInfo.Number >> (EStatAllFields::StartShift + EStatMetaFlags::Shift)) &amp; EStatMetaFlags::IsCycle) == EStatMetaFlags::IsCycle">
      {{Count={DebugStatData.CCAndDuration[0]},Cycles={DebugStatData.CCAndDuration[1]} NameAndInfo={NameAndInfo}}}
    </DisplayString>

    <!--ST_double -->
    <DisplayString Condition="(EStatDataType::Type)((NameAndInfo.NameAndInfo.Number >> (EStatAllFields::StartShift + EStatDataType::Shift)) &amp; EStatDataType::Mask) == EStatDataType::ST_double">
      {{Float={DebugStatData.Float} NameAndInfo={NameAndInfo}}}
    </DisplayString>

    <!--ST_FName -->
    <DisplayString Condition="(EStatDataType::Type)((NameAndInfo.NameAndInfo.Number >> (EStatAllFields::StartShift + EStatDataType::Shift)) &amp; EStatDataType::Mask) == EStatDataType::ST_FName">
      {{Name={(FNameEntryId&amp;)DebugStatData.Cycles} NameAndInfo={NameAndInfo}}}
    </DisplayString>

    <!--ST_Ptr -->
    <DisplayString Condition="(EStatDataType::Type)((NameAndInfo.NameAndInfo.Number >> (EStatAllFields::StartShift + EStatDataType::Shift)) &amp; EStatDataType::Mask) == EStatDataType::ST_Ptr">
      {{Ptr={DebugStatData.Ptr} NameAndInfo={NameAndInfo}}}
    </DisplayString>
  </Type>

  <!-- FAllocationInfo -->
  <!--
		uint64 OldPtr;
		uint64 Ptr;
		int64 Size;
		FName EncodedCallstack;
		uint32 SequenceTag;
		EMemoryOperation Op; Alloc=1, Free=2, Realloc=3
		bool bHasBrokenCallstack;
	-->
  <Type Name="FAllocationInfo">
    <!-- Alloc -->
    <DisplayString Condition="Op == 1" >
      {{A SeqTag={SequenceTag} Ptr={Ptr} Size={Size} Callstack={EncodedCallstack} bHasBrokenCallstack={bHasBrokenCallstack}}}
    </DisplayString>

    <!-- Free -->
    <DisplayString Condition="Op == 2" >
      {{F SeqTag={SequenceTag} Ptr={Ptr} bHasBrokenCallstack={bHasBrokenCallstack}}}
    </DisplayString>

    <!-- Realloc -->
    <DisplayString Condition="Op == 3" >
      {{R SeqTag={SequenceTag} OldPtr={OldPtr} Ptr={Ptr} NewSize={Size} Callstack={EncodedCallstack} bHasBrokenCallstack={bHasBrokenCallstack}}}
    </DisplayString>
  </Type>

  <Type Name="FThreadSafeCounter">
    <DisplayString>{Counter}</DisplayString>
  </Type>

  <Type Name="FThreadSafeBool">
    <DisplayString Condition="Counter==0">False</DisplayString>
    <DisplayString Condition="Counter==1">True</DisplayString>
  </Type>

  <!-- FTimespan visualizer -->
  <Type Name="FTimespan">
    <DisplayString>Ticks = {Ticks}</DisplayString>
    <Expand>
      <Item Name="Total Milliseconds">Ticks / ETimespan::TicksPerMillisecond</Item>
      <Item Name="Total Seconds">Ticks / ETimespan::TicksPerSecond</Item>
      <Item Name="Total Minutes">Ticks / ETimespan::TicksPerMinute</Item>
      <Item Name="Total Hours">Ticks / ETimespan::TicksPerHour</Item>
      <Item Name="Total Days">Ticks / ETimespan::TicksPerDay</Item>
    </Expand>
  </Type>

  <Type Name="FAsyncPackageData">
    <DisplayString>ExportCount={ExportCount}, ExportBundleCount={ExportBundleCount}, ImportedPackages={ImportedAsyncPackages.ArrayNum}</DisplayString>
  </Type>

  <Type Name="FEventLoadNode2">
    <DisplayString Condition="bDone.Element">Done {Spec-&gt;Func,na}</DisplayString>
    <DisplayString Condition="bFired.Element">Fired {Spec-&gt;Func,na}</DisplayString>
    <DisplayString>Queued (BarrierCount={BarrierCount.Element}) {Spec-&gt;Func,na}</DisplayString>
  </Type>

  <Type Name="FExportObject">
    <DisplayString Condition="Object != 0">{Object-&gt;NamePrivate} ({Object-&gt;ObjectFlags,x})</DisplayString>
    <DisplayString Condition="!bFiltered &amp;&amp; !bExportLoadFailed">Null (Create)</DisplayString>
    <DisplayString Condition="bFiltered">Null (Filtered)</DisplayString>
    <DisplayString>Null (Failed)</DisplayString>
  </Type>

  <Type Name="FAsyncPackageDesc2">
    <DisplayString Condition="CustomPackageId.Id != CustomPackageId.InvalidId">{CustomPackageName} ({CustomPackageId.Id,X}) {DiskPackageName} ({DiskPackageId.Id,X})</DisplayString>
    <DisplayString>{DiskPackageName} ({DiskPackageId.Id,X})</DisplayString>
  </Type>

  <Type Name="FAsyncPackage2">
    <DisplayString>{Desc}</DisplayString>
  </Type>

  <Type Name="FPackageId">
    <DisplayString Condition="Id != InvalidId">{Id,X}</DisplayString>
    <DisplayString>Null</DisplayString>
  </Type>

  <Type Name="FPackageIndex">
    <DisplayString Condition="Index &lt; 0">ImportIndex={-Index-1}</DisplayString>
    <DisplayString Condition="Index &gt; 0">ExportIndex={Index-1}</DisplayString>
    <DisplayString>Null</DisplayString>
  </Type>

  <Type Name="FPackageObjectIndex">
    <DisplayString Condition="TypeAndId != Invalid">{(EType)(TypeAndId >> TypeShift)} {TypeAndId &amp; IndexMask,X}</DisplayString>
    <DisplayString>Null</DisplayString>
  </Type>

  <Type Name="TPackageStoreEntryCArrayView&lt;*&gt;">
    <DisplayString Condition="ArrayNum == 0">Empty</DisplayString>
    <DisplayString>Num={ArrayNum}, Data[0]={($T1*)((uint8*)this + OffsetToDataFromThis)}</DisplayString>
    <Expand>
      <ArrayItems Condition="ArrayNum &gt;= 0">
        <Size>ArrayNum</Size>
        <ValuePointer>($T1*)((char*)this + OffsetToDataFromThis)</ValuePointer>
      </ArrayItems>
    </Expand>
  </Type>

  <Type Name="FVector">
    <DisplayString>{{X={X} Y={Y} Z={Z}}}</DisplayString>
    <Expand HideRawView="true">
      <Item Name="X">X</Item>
      <Item Name="Y">Y</Item>
      <Item Name="Z">Z</Item>
      <Item Name="||V||&#xB2;">X*X + Y*Y + Z*Z</Item>
    </Expand>
  </Type>

  <Type Name="FQuat">
    <DisplayString>{{X={X} Y={Y} Z={Z} W={W}}}</DisplayString>
    <Expand HideRawView="true">
      <Item Name="X">X</Item>
      <Item Name="Y">Y</Item>
      <Item Name="Z">Z</Item>
      <Item Name="W">W</Item>
      <Item Name="||Q||&#xB2;">X*X + Y*Y + Z*Z + W*W</Item>
    </Expand>
  </Type>

  <Type Name="FRotator">
    <DisplayString>{{Pitch={Pitch} Yaw={Yaw} Roll={Roll}}}</DisplayString>
    <Expand HideRawView="true">
      <Item Name="Pitch (Y)">Pitch</Item>
      <Item Name="Yaw (Z)">Yaw</Item>
      <Item Name="Roll (X)">Roll</Item>
    </Expand>
  </Type>

  <Type Name="FTransform">
    <DisplayString>{{Translation={{X={Translation.m128_f32[0]} Y={Translation.m128_f32[1]} Z={Translation.m128_f32[2]}}} Rotation={{X={Rotation.m128_f32[0]} Y={Rotation.m128_f32[1]} Z={Rotation.m128_f32[2]} W={Rotation.m128_f32[3]}}}}}</DisplayString>
    <Expand>
      <Synthetic Name="Translation">
        <DisplayString>{{X={Translation.m128_f32[0]} Y={Translation.m128_f32[1]} Z={Translation.m128_f32[2]}}}</DisplayString>
        <Expand>
          <Item Name="X">Translation.m128_f32[0]</Item>
          <Item Name="Y">Translation.m128_f32[1]</Item>
          <Item Name="Z">Translation.m128_f32[2]</Item>
          <Item Name="||V||&#xB2;">Translation.m128_f32[0]*Translation.m128_f32[0] + Translation.m128_f32[1]*Translation.m128_f32[1] + Translation.m128_f32[2]*Translation.m128_f32[2]</Item>
        </Expand>
      </Synthetic>
      <Synthetic Name="Rotation">
        <DisplayString>{{X={Rotation.m128_f32[0]} Y={Rotation.m128_f32[1]} Z={Rotation.m128_f32[2]} W={Rotation.m128_f32[3]}}}</DisplayString>
        <Expand>
          <Item Name="X">Rotation.m128_f32[0]</Item>
          <Item Name="Y">Rotation.m128_f32[1]</Item>
          <Item Name="Z">Rotation.m128_f32[2]</Item>
          <Item Name="W">Rotation.m128_f32[3]</Item>
          <Item Name="||Q||&#xB2;">Rotation.m128_f32[0]*Rotation.m128_f32[0] + Rotation.m128_f32[1]*Rotation.m128_f32[1] + Rotation.m128_f32[2]*Rotation.m128_f32[2] + Rotation.m128_f32[3]*Rotation.m128_f32[3]</Item>
        </Expand>
      </Synthetic>
      <Synthetic Name="Scale3D">
        <DisplayString>{{X={Scale3D.m128_f32[0]} Y={Scale3D.m128_f32[1]} Z={Scale3D.m128_f32[2]}}}</DisplayString>
        <Expand>
          <Item Name="X">Scale3D.m128_f32[0]</Item>
          <Item Name="Y">Scale3D.m128_f32[1]</Item>
          <Item Name="Z">Scale3D.m128_f32[2]</Item>
        </Expand>
      </Synthetic>
    </Expand>
  </Type>

  <!-- TEnumAsByte visualizer -->
  <Type Name="TEnumAsByte&lt;*&gt;">
    <DisplayString>{($T1)Value}</DisplayString>
  </Type>

  <!-- UObjectBase visualizer -->
  <Type Name="UObjectBase">
    <DisplayString>(Name={NamePrivate})</DisplayString>
  </Type>

  <!-- FFieldClass visualizer -->
  <Type Name="FFieldClass">
    <DisplayString>(Name={Name})</DisplayString>
  </Type>
  
  <!-- FFieldVariant visualizer -->
  <Type Name="FFieldVariant">
    <DisplayString Condition="bIsUObject==0">{Container.Field}</DisplayString>
    <DisplayString Condition="bIsUObject==1">{Container.Object}</DisplayString>
    <Expand>
      <Item Name="Field" Condition="bIsUObject==0">Container.Field</Item>
      <Item Name="Object" Condition="bIsUObject==1">Container.Object</Item>
    </Expand>    
  </Type>
  
  <!-- FField visualizer -->
  <Type Name="FField">
    <DisplayString>(Name={NamePrivate})</DisplayString>
  </Type>

  <!-- FChunkedFixedUObjectArray visualizer -->
  <Type Name="FChunkedFixedUObjectArray">
    <DisplayString Condition="NumElements == 0">Empty</DisplayString>
    <DisplayString Condition="NumElements &lt; 0">Invalid</DisplayString>
    <DisplayString Condition="NumElements &gt; 0">NumElements={NumElements}, NumChunks={NumChunks}, {NumElementsPerChunk}</DisplayString>

    <Expand>
      <IndexListItems Condition="NumElements &gt; 0">
        <Size>NumElements</Size>
        <ValueNode>
          Objects[$i / NumElementsPerChunk][$i % NumElementsPerChunk]
        </ValueNode>
      </IndexListItems>
    </Expand>
  </Type>

  <!-- TArray<*,TFixedAllocator<*> > visualizer -->
  <Type Name="TArray&lt;*,TFixedAllocator&lt;*&gt;&gt;">
    <DisplayString Condition="ArrayNum == 0">Empty</DisplayString>
    <DisplayString Condition="ArrayNum &lt; 0">Invalid</DisplayString>
    <DisplayString Condition="ArrayMax &lt; ArrayNum">Invalid</DisplayString>
    <DisplayString Condition="ArrayMax &gt;= ArrayNum">Num={ArrayNum}</DisplayString>
    <Expand>
      <ArrayItems Condition="ArrayNum &lt;= ArrayMax">
        <Size>ArrayNum</Size>
        <ValuePointer>(TArray&lt;$T1,TFixedAllocator&lt;$T2&gt; &gt;::ElementType*)AllocatorInstance.InlineData</ValuePointer>
      </ArrayItems>
    </Expand>
  </Type>

  <!-- TArray<*,TInlineAllocator<*,*> > visualizer -->
  <Type Name="TArray&lt;*,TInlineAllocator&lt;*,*&gt;&gt;">
    <DisplayString Condition="ArrayNum == 0">Empty</DisplayString>
    <DisplayString Condition="ArrayNum &lt; 0">Invalid</DisplayString>
    <DisplayString Condition="ArrayMax &lt; ArrayNum">Invalid</DisplayString>
    <DisplayString Condition="ArrayMax &gt;= ArrayNum">Num={ArrayNum}</DisplayString>
    <Expand>
      <ArrayItems Condition="ArrayNum &lt;= ArrayMax">
        <Size>ArrayNum</Size>
        <ValuePointer Condition="AllocatorInstance.SecondaryData.Data == 0">(TArray&lt;$T1,TInlineAllocator&lt;$T2,$T3&gt; &gt;::ElementType*)AllocatorInstance.InlineData</ValuePointer>
        <ValuePointer Condition="AllocatorInstance.SecondaryData.Data != 0">(TArray&lt;$T1,TInlineAllocator&lt;$T2,$T3&gt; &gt;::ElementType*)AllocatorInstance.SecondaryData.Data</ValuePointer>
      </ArrayItems>
    </Expand>
  </Type>

  <!-- TArray<*,TMemoryImageAllocator<*>> visualizer -->
  <Type Name="TArray&lt;*,TMemoryImageAllocator&lt;*&gt;&gt;">
    <DisplayString Condition="ArrayNum == 0">Empty</DisplayString>
    <DisplayString Condition="ArrayNum &lt; 0">Invalid</DisplayString>
    <DisplayString Condition="ArrayMax &lt; ArrayNum">Invalid</DisplayString>
    <DisplayString Condition="ArrayMax &gt;= ArrayNum">Num={ArrayNum}</DisplayString>
    <DisplayString>Ptr={AllocatorInstance.Data.Ptr}</DisplayString>
    <Expand>
      <ArrayItems Condition="ArrayNum &lt;= ArrayMax">
        <Size>ArrayNum</Size>
        <ValuePointer Condition="(AllocatorInstance.Data.OffsetFromThis &amp; 1) != 0">(TArray&lt;$T1,TMemoryImageAllocator&lt;$T2&gt; &gt;::ElementType*)( (char*)&amp;AllocatorInstance.Data + (AllocatorInstance.Data.OffsetFromThis >> 1))</ValuePointer>
        <ValuePointer Condition="(AllocatorInstance.Data.OffsetFromThis &amp; 1) == 0">(TArray&lt;$T1,TMemoryImageAllocator&lt;$T2&gt; &gt;::ElementType*)AllocatorInstance.Data.Ptr</ValuePointer>
      </ArrayItems>
    </Expand>
  </Type>

  <!-- TArray visualizer -->
  <Type Name="TArray&lt;*,*&gt;">
    <DisplayString Condition="ArrayNum == 0">Empty</DisplayString>
    <DisplayString Condition="ArrayNum &lt; 0">Invalid</DisplayString>
    <DisplayString Condition="ArrayMax &lt; ArrayNum">Invalid</DisplayString>
    <DisplayString Condition="ArrayMax &gt;= ArrayNum">Num={ArrayNum}</DisplayString>
    <Expand>
      <ArrayItems Condition="ArrayNum &lt;= ArrayMax">
        <Size>ArrayNum</Size>
        <ValuePointer>(TArray&lt;$T1,$T2&gt;::ElementType*)AllocatorInstance.Data</ValuePointer>
      </ArrayItems>
    </Expand>
  </Type>

  <!-- TArray<char> visualizers -->
  <Type Name="TArray&lt;char,*&gt;">
    <DisplayString Condition="ArrayNum == 0">Empty</DisplayString>
    <DisplayString Condition="ArrayNum &lt; 0">Invalid</DisplayString>
    <DisplayString Condition="ArrayMax &lt; ArrayNum">Invalid</DisplayString>
    <DisplayString Condition="ArrayMax &gt;= ArrayNum">Num={ArrayNum} {(char*)AllocatorInstance.Data,[ArrayNum]s}</DisplayString>
    <StringView Condition="ArrayMax &gt;= ArrayNum">(char*)AllocatorInstance.Data,[ArrayNum]s</StringView>
    <Expand>
      <ArrayItems Condition="ArrayNum &lt;= ArrayMax">
        <Size>ArrayNum</Size>
        <ValuePointer>(char*)AllocatorInstance.Data</ValuePointer>
      </ArrayItems>
    </Expand>
  </Type>
  <Type Name="TArray&lt;char,TFixedAllocator&lt;*&gt;&gt;">
    <DisplayString Condition="ArrayNum == 0">Empty</DisplayString>
    <DisplayString Condition="ArrayNum &lt; 0">Invalid</DisplayString>
    <DisplayString Condition="ArrayMax &lt; ArrayNum">Invalid</DisplayString>
    <DisplayString Condition="ArrayMax &gt;= ArrayNum">Num={ArrayNum} {(char*)AllocatorInstance.InlineData,[ArrayNum]s}</DisplayString>
    <StringView Condition="ArrayMax &gt;= ArrayNum">(char*)AllocatorInstance.InlineData,[ArrayNum]s</StringView>
    <Expand>
      <ArrayItems Condition="ArrayNum &lt;= ArrayMax">
        <Size>ArrayNum</Size>
        <ValuePointer>(char*)AllocatorInstance.InlineData</ValuePointer>
      </ArrayItems>
    </Expand>
  </Type>
  <Type Name="TArray&lt;char,TInlineAllocator&lt;*,*&gt;&gt;">
    <DisplayString Condition="ArrayNum == 0">Empty</DisplayString>
    <DisplayString Condition="ArrayNum &lt; 0">Invalid</DisplayString>
    <DisplayString Condition="ArrayMax &lt; ArrayNum">Invalid</DisplayString>
    <DisplayString Condition="ArrayMax &gt;= ArrayNum &amp;&amp; AllocatorInstance.SecondaryData.Data == 0">Num={ArrayNum} {(char*)AllocatorInstance.InlineData,[ArrayNum]s}</DisplayString>
    <DisplayString Condition="ArrayMax &gt;= ArrayNum &amp;&amp; AllocatorInstance.SecondaryData.Data != 0">Num={ArrayNum} {(char*)AllocatorInstance.SecondaryData.Data,[ArrayNum]s}</DisplayString>
    <StringView Condition="ArrayMax &gt;= ArrayNum &amp;&amp; AllocatorInstance.SecondaryData.Data == 0">(char*)AllocatorInstance.InlineData,[ArrayNum]s</StringView>
    <StringView Condition="ArrayMax &gt;= ArrayNum &amp;&amp; AllocatorInstance.SecondaryData.Data != 0">(char*)AllocatorInstance.SecondaryData.Data,[ArrayNum]s</StringView>
    <Expand>
      <ArrayItems Condition="ArrayNum &lt;= ArrayMax">
        <Size>ArrayNum</Size>
        <ValuePointer Condition="AllocatorInstance.SecondaryData.Data == 0">(char*)AllocatorInstance.InlineData</ValuePointer>
        <ValuePointer Condition="AllocatorInstance.SecondaryData.Data != 0">(char*)AllocatorInstance.SecondaryData.Data</ValuePointer>
      </ArrayItems>
    </Expand>
  </Type>

  <!-- TArray<unsigned char> visualizers -->
  <Type Name="TArray&lt;unsigned char,*&gt;">
    <DisplayString Condition="ArrayNum == 0">Empty</DisplayString>
    <DisplayString Condition="ArrayNum &lt; 0">Invalid</DisplayString>
    <DisplayString Condition="ArrayMax &lt; ArrayNum">Invalid</DisplayString>
    <DisplayString Condition="ArrayMax &gt;= ArrayNum">Num={ArrayNum} {(unsigned char*)AllocatorInstance.Data,[ArrayNum]s}</DisplayString>
    <StringView Condition="ArrayMax &gt;= ArrayNum">(unsigned char*)AllocatorInstance.Data,[ArrayNum]s</StringView>
    <Expand>
      <ArrayItems Condition="ArrayNum &lt;= ArrayMax">
        <Size>ArrayNum</Size>
        <ValuePointer>(unsigned char*)AllocatorInstance.Data</ValuePointer>
      </ArrayItems>
    </Expand>
  </Type>
  <Type Name="TArray&lt;unsigned char,TFixedAllocator&lt;*&gt;&gt;">
    <DisplayString Condition="ArrayNum == 0">Empty</DisplayString>
    <DisplayString Condition="ArrayNum &lt; 0">Invalid</DisplayString>
    <DisplayString Condition="ArrayMax &lt; ArrayNum">Invalid</DisplayString>
    <DisplayString Condition="ArrayMax &gt;= ArrayNum">Num={ArrayNum} {(unsigned char*)AllocatorInstance.InlineData,[ArrayNum]s}</DisplayString>
    <StringView Condition="ArrayMax &gt;= ArrayNum">(unsigned char*)AllocatorInstance.InlineData,[ArrayNum]s</StringView>
    <Expand>
      <ArrayItems Condition="ArrayNum &lt;= ArrayMax">
        <Size>ArrayNum</Size>
        <ValuePointer>(unsigned char*)AllocatorInstance.InlineData</ValuePointer>
      </ArrayItems>
    </Expand>
  </Type>
  <Type Name="TArray&lt;unsigned char,TInlineAllocator&lt;*,*&gt;&gt;">
    <DisplayString Condition="ArrayNum == 0">Empty</DisplayString>
    <DisplayString Condition="ArrayNum &lt; 0">Invalid</DisplayString>
    <DisplayString Condition="ArrayMax &lt; ArrayNum">Invalid</DisplayString>
    <DisplayString Condition="ArrayMax &gt;= ArrayNum &amp;&amp; AllocatorInstance.SecondaryData.Data == 0">Num={ArrayNum} {(unsigned char*)AllocatorInstance.InlineData,[ArrayNum]s}</DisplayString>
    <DisplayString Condition="ArrayMax &gt;= ArrayNum &amp;&amp; AllocatorInstance.SecondaryData.Data != 0">Num={ArrayNum} {(unsigned char*)AllocatorInstance.SecondaryData.Data,[ArrayNum]s}</DisplayString>
    <StringView Condition="ArrayMax &gt;= ArrayNum &amp;&amp; AllocatorInstance.SecondaryData.Data == 0">(unsigned char*)AllocatorInstance.InlineData,[ArrayNum]s</StringView>
    <StringView Condition="ArrayMax &gt;= ArrayNum &amp;&amp; AllocatorInstance.SecondaryData.Data != 0">(unsigned char*)AllocatorInstance.SecondaryData.Data,[ArrayNum]s</StringView>
    <Expand>
      <ArrayItems Condition="ArrayNum &lt;= ArrayMax">
        <Size>ArrayNum</Size>
        <ValuePointer Condition="AllocatorInstance.SecondaryData.Data == 0">(unsigned char*)AllocatorInstance.InlineData</ValuePointer>
        <ValuePointer Condition="AllocatorInstance.SecondaryData.Data != 0">(unsigned char*)AllocatorInstance.SecondaryData.Data</ValuePointer>
      </ArrayItems>
    </Expand>
  </Type>

  <!-- TArray<wchar_t> visualizers -->
  <Type Name="TArray&lt;wchar_t,*&gt;">
    <DisplayString Condition="ArrayNum == 0">Empty</DisplayString>
    <DisplayString Condition="ArrayNum &lt; 0">Invalid</DisplayString>
    <DisplayString Condition="ArrayMax &lt; ArrayNum">Invalid</DisplayString>
    <DisplayString Condition="ArrayMax &gt;= ArrayNum">Num={ArrayNum} {(wchar_t*)AllocatorInstance.Data,[ArrayNum]su}</DisplayString>
    <StringView Condition="ArrayMax &gt;= ArrayNum">(wchar_t*)AllocatorInstance.Data,[ArrayNum]su</StringView>
    <Expand>
      <ArrayItems Condition="ArrayNum &lt;= ArrayMax">
        <Size>ArrayNum</Size>
        <ValuePointer>(wchar_t*)AllocatorInstance.Data</ValuePointer>
      </ArrayItems>
    </Expand>
  </Type>
  <Type Name="TArray&lt;wchar_t,TFixedAllocator&lt;*&gt;&gt;">
    <DisplayString Condition="ArrayNum == 0">Empty</DisplayString>
    <DisplayString Condition="ArrayNum &lt; 0">Invalid</DisplayString>
    <DisplayString Condition="ArrayMax &lt; ArrayNum">Invalid</DisplayString>
    <DisplayString Condition="ArrayMax &gt;= ArrayNum">Num={ArrayNum} {(wchar_t*)AllocatorInstance.InlineData,[ArrayNum]su}</DisplayString>
    <StringView Condition="ArrayMax &gt;= ArrayNum">(wchar_t*)AllocatorInstance.InlineData,[ArrayNum]su</StringView>
    <Expand>
      <ArrayItems Condition="ArrayNum &lt;= ArrayMax">
        <Size>ArrayNum</Size>
        <ValuePointer>(wchar_t*)AllocatorInstance.InlineData</ValuePointer>
      </ArrayItems>
    </Expand>
  </Type>
  <Type Name="TArray&lt;wchar_t,TInlineAllocator&lt;*,*&gt;&gt;">
    <DisplayString Condition="ArrayNum == 0">Empty</DisplayString>
    <DisplayString Condition="ArrayNum &lt; 0">Invalid</DisplayString>
    <DisplayString Condition="ArrayMax &lt; ArrayNum">Invalid</DisplayString>
    <DisplayString Condition="ArrayMax &gt;= ArrayNum &amp;&amp; AllocatorInstance.SecondaryData.Data == 0">Num={ArrayNum} {(wchar_t*)AllocatorInstance.InlineData,[ArrayNum]su}</DisplayString>
    <DisplayString Condition="ArrayMax &gt;= ArrayNum &amp;&amp; AllocatorInstance.SecondaryData.Data != 0">Num={ArrayNum} {(wchar_t*)AllocatorInstance.SecondaryData.Data,[ArrayNum]su}</DisplayString>
    <StringView Condition="ArrayMax &gt;= ArrayNum &amp;&amp; AllocatorInstance.SecondaryData.Data == 0">(wchar_t*)AllocatorInstance.InlineData,[ArrayNum]su</StringView>
    <StringView Condition="ArrayMax &gt;= ArrayNum &amp;&amp; AllocatorInstance.SecondaryData.Data != 0">(wchar_t*)AllocatorInstance.SecondaryData.Data,[ArrayNum]su</StringView>
    <Expand>
      <ArrayItems Condition="ArrayNum &lt;= ArrayMax">
        <Size>ArrayNum</Size>
        <ValuePointer Condition="AllocatorInstance.SecondaryData.Data == 0">(wchar_t*)AllocatorInstance.InlineData</ValuePointer>
        <ValuePointer Condition="AllocatorInstance.SecondaryData.Data != 0">(wchar_t*)AllocatorInstance.SecondaryData.Data</ValuePointer>
      </ArrayItems>
    </Expand>
  </Type>

  <!-- TArrayView visualizer -->
  <Type Name="TArrayView&lt;*&gt;">
    <DisplayString Condition="ArrayNum == 0">Empty</DisplayString>
    <DisplayString Condition="ArrayNum &lt; 0">Invalid</DisplayString>
    <DisplayString Condition="ArrayNum &gt; 0">Num={ArrayNum}</DisplayString>
    <Expand>
      <ArrayItems Condition="ArrayNum &gt; 0">
        <Size>ArrayNum</Size>
        <ValuePointer>DataPtr</ValuePointer>
      </ArrayItems>
    </Expand>
  </Type>

  <!-- TIndirectArray visualizer -->
  <Type Name="TIndirectArray&lt;*,*&gt;">
    <DisplayString Condition="Array.ArrayNum == 0">Empty</DisplayString>
    <DisplayString Condition="Array.ArrayNum &lt; 0">Invalid</DisplayString>
    <DisplayString Condition="Array.ArrayMax &lt; Array.ArrayNum">Invalid</DisplayString>
    <DisplayString Condition="Array.ArrayMax &gt;= Array.ArrayNum">Num={Array.ArrayNum}</DisplayString>
    <Expand>
      <IndexListItems Condition="Array.ArrayNum &lt;= Array.ArrayMax">
        <Size>Array.ArrayNum</Size>
        <ValueNode>*((TIndirectArray&lt;$T1,$T2&gt;::ElementType**)Array.AllocatorInstance.Data)[$i]</ValueNode>
      </IndexListItems>
    </Expand>
  </Type>

  <!-- TChunkedArray visualizer -->
  <Type Name="TChunkedArray&lt;*,*&gt;">
    <DisplayString Condition="NumElements == 0">Empty</DisplayString>
    <DisplayString Condition="NumElements &lt; 0">Invalid</DisplayString>
    <DisplayString Condition="NumElements &gt; 0">NumElements={NumElements}, NumChunks={Chunks.Array.ArrayNum}, {NumElementsPerChunk}</DisplayString>

    <Expand>
      <IndexListItems Condition="NumElements &gt; 0">
        <Size>NumElements</Size>
        <ValueNode>
          *(
          *(
          (TChunkedArray&lt;$T1,$T2&gt;::ElementType**)Chunks.Array.AllocatorInstance.Data + ($i / NumElementsPerChunk)
          ) + ($i % NumElementsPerChunk)
          )
        </ValueNode>
      </IndexListItems>
    </Expand>
  </Type>

  <!-- TSparseArray visualizer -->
  <Type Name="TSparseArray&lt;*,*&gt;">
    <DisplayString Condition="(Data.ArrayNum - NumFreeIndices) &lt;= 0">Empty</DisplayString>
    <DisplayString Condition="Data.ArrayNum &lt;= Data.ArrayMax">Num={Data.ArrayNum - NumFreeIndices}</DisplayString>
    <Expand>
      <IndexListItems Condition="Data.ArrayNum &gt; 0 &amp;&amp; Data.ArrayNum &lt;= Data.ArrayMax">
        <Size>Data.ArrayNum</Size>
        <ValueNode Condition="(AllocationFlags.AllocatorInstance.SecondaryData.Data != 0) &amp;&amp; (reinterpret_cast&lt;uint32*&gt;(AllocationFlags.AllocatorInstance.SecondaryData.Data)[$i/32]&gt;&gt;($i%32) &amp; 1) != 0">*reinterpret_cast&lt;ElementType*&gt;(reinterpret_cast&lt;FElementOrFreeListLink*&gt;(Data.AllocatorInstance.Data) + $i)</ValueNode>
        <ValueNode Condition="(AllocationFlags.AllocatorInstance.SecondaryData.Data == 0) &amp;&amp; (reinterpret_cast&lt;uint32*&gt;(AllocationFlags.AllocatorInstance.InlineData        )[$i/32]&gt;&gt;($i%32) &amp; 1) != 0">*reinterpret_cast&lt;ElementType*&gt;(reinterpret_cast&lt;FElementOrFreeListLink*&gt;(Data.AllocatorInstance.Data) + $i)</ValueNode>
        <ValueNode Condition="(AllocationFlags.AllocatorInstance.SecondaryData.Data != 0) &amp;&amp; (reinterpret_cast&lt;uint32*&gt;(AllocationFlags.AllocatorInstance.SecondaryData.Data)[$i/32]&gt;&gt;($i%32) &amp; 1) == 0">"Invalid",sb</ValueNode>
        <ValueNode Condition="(AllocationFlags.AllocatorInstance.SecondaryData.Data == 0) &amp;&amp; (reinterpret_cast&lt;uint32*&gt;(AllocationFlags.AllocatorInstance.InlineData        )[$i/32]&gt;&gt;($i%32) &amp; 1) == 0">"Invalid",sb</ValueNode>
      </IndexListItems>
    </Expand>
  </Type>

  <!-- TBitArray visualizer -->
  <Type Name="TBitArray&lt;*&gt;">
    <DisplayString Condition="NumBits == 0">Empty</DisplayString>
    <DisplayString Condition="NumBits &lt; 0">Invalid</DisplayString>
    <DisplayString Condition="NumBits &gt; 0">NumBits={NumBits}, MaxBits={MaxBits}</DisplayString>
    <Expand>
      <IndexListItems Condition="NumBits &gt; 0">
        <Size>NumBits</Size>
        <ValueNode Condition="(AllocatorInstance.SecondaryData.Data != 0) &amp;&amp; (reinterpret_cast&lt;uint32*&gt;(AllocatorInstance.SecondaryData.Data	)[$i/32]&gt;&gt;($i%32) &amp; 1) != 0">1</ValueNode>
        <ValueNode Condition="(AllocatorInstance.SecondaryData.Data == 0) &amp;&amp; (reinterpret_cast&lt;uint32*&gt;(AllocatorInstance.InlineData			)[$i/32]&gt;&gt;($i%32) &amp; 1) != 0">1</ValueNode>
        <ValueNode Condition="(AllocatorInstance.SecondaryData.Data != 0) &amp;&amp; (reinterpret_cast&lt;uint32*&gt;(AllocatorInstance.SecondaryData.Data	)[$i/32]&gt;&gt;($i%32) &amp; 1) == 0">0</ValueNode>
        <ValueNode Condition="(AllocatorInstance.SecondaryData.Data == 0) &amp;&amp; (reinterpret_cast&lt;uint32*&gt;(AllocatorInstance.InlineData			)[$i/32]&gt;&gt;($i%32) &amp; 1) == 0">0</ValueNode>
      </IndexListItems>
    </Expand>
  </Type>

  <!-- TRingBuffer visualizer -->
  <Type Name="TRingBuffer&lt;*,*&gt;">
    <DisplayString Condition="AfterBack == Front">Empty</DisplayString>
    <DisplayString Condition="AfterBack - Front &lt;= IndexMask+1">Num={AfterBack - Front}</DisplayString>
    <DisplayString Condition="AfterBack - Front &gt; IndexMask+1">Invalid</DisplayString>
    <Expand>
      <IndexListItems Condition="AfterBack - Front &lt;= IndexMask+1">
        <Size>AfterBack - Front</Size>
        <ValueNode>AllocationData[(Front + $i) &amp; IndexMask]</ValueNode>
      </IndexListItems>
    </Expand>
  </Type>

  <!-- TPair visualizer -->
  <Type Name="TPair&lt;*,*&gt;">
    <DisplayString>({Key}, {Value})</DisplayString>
  </Type>

  <!-- TSharedPtr visualizer -->
  <Type Name="TSharedPtr&lt;*,*&gt;">
    <DisplayString Condition="Object == 0">Null</DisplayString>
    <DisplayString Condition="Object != 0">Ptr={(void*)Object}, SharedRefs={SharedReferenceCount.ReferenceController->SharedReferenceCount}, WeakRefs={SharedReferenceCount.ReferenceController->WeakReferenceCount}, Object={*Object}</DisplayString>
    <Expand>
      <Item Condition="Object != 0" Name="[SharedReferenceCount]">SharedReferenceCount.ReferenceController->SharedReferenceCount</Item>
      <Item Condition="Object != 0" Name="[WeakReferenceCount]">SharedReferenceCount.ReferenceController->WeakReferenceCount</Item>
      <Item Condition="Object != 0" Name="[Ptr]">(void*)Object</Item>
      <ExpandedItem Condition="Object != 0">*Object</ExpandedItem>
    </Expand>
  </Type>

  <!-- TSharedRef visualizer -->
  <Type Name="TSharedRef&lt;*,*&gt;">
    <DisplayString Condition="Object != 0">Ptr={(void*)Object}, SharedRefs={SharedReferenceCount.ReferenceController->SharedReferenceCount}, WeakRefs={SharedReferenceCount.ReferenceController->WeakReferenceCount}, Object={*Object}</DisplayString>
    <Expand>
      <Item Condition="Object != 0" Name="[SharedReferenceCount]">SharedReferenceCount.ReferenceController->SharedReferenceCount</Item>
      <Item Condition="Object != 0" Name="[WeakReferenceCount]">SharedReferenceCount.ReferenceController->WeakReferenceCount</Item>
      <Item Condition="Object != 0" Name="[Ptr]">(void*)Object</Item>
      <ExpandedItem Condition="Object != 0">*Object</ExpandedItem>
    </Expand>
  </Type>

  <!-- TWeakPtr visualizer -->
  <Type Name="TWeakPtr&lt;*,*&gt;">
    <DisplayString Condition="Object == 0">Null</DisplayString>
    <DisplayString Condition="WeakReferenceCount.ReferenceController->SharedReferenceCount == 0">Object has been destroyed</DisplayString>
    <DisplayString Condition="Object != 0">Ptr={(void*)Object}, SharedRefs={WeakReferenceCount.ReferenceController->SharedReferenceCount}, WeakRefs={WeakReferenceCount.ReferenceController->WeakReferenceCount}, Object={*Object}</DisplayString>
    <Expand>
      <Item Condition="Object != 0" Name="[SharedReferenceCount]">WeakReferenceCount.ReferenceController->SharedReferenceCount</Item>
      <Item Condition="Object != 0" Name="[WeakReferenceCount]">WeakReferenceCount.ReferenceController->WeakReferenceCount</Item>
      <Item Condition="Object != 0 &amp;&amp; WeakReferenceCount.ReferenceController->SharedReferenceCount > 0" Name="[Ptr]">(void*)Object</Item>
      <ExpandedItem Condition="Object != 0 &amp;&amp; WeakReferenceCount.ReferenceController->SharedReferenceCount > 0">*Object</ExpandedItem>
    </Expand>
  </Type>

  <!-- TMemoryImagePtr visualizer -->
  <Type Name="TMemoryImagePtr&lt;*&gt;">
    <DisplayString Condition="Ptr == 0">Null</DisplayString>
    <DisplayString Condition="Ptr != 0"></DisplayString>
    <Expand>
      <Item Condition="Ptr != 0 &amp;&amp; (OffsetFromThis &amp; 1) != 0" Name="Object">($T1*)( (char*)this + (OffsetFromThis >> 1))</Item>
      <Item Condition="Ptr != 0 &amp;&amp; (OffsetFromThis &amp; 1) == 0" Name="Object">($T1*)Ptr</Item>
    </Expand>
  </Type>

  <Type Name="FHashedNameDebugString">
    <DisplayString Condition="String.Ptr == 0">Empty</DisplayString>
    <DisplayString Condition="(String.OffsetFromThis &amp; 1) != 0">{(char*)this + (String.OffsetFromThis >> 1)}</DisplayString>
    <DisplayString>{String.Ptr}</DisplayString>
  </Type>

  <!-- TMapBase visualizer -->
  <Type Name="TMapBase&lt;*,*,*,*&gt;">
    <DisplayString>{Pairs}</DisplayString>
    <Expand>
      <ExpandedItem>Pairs</ExpandedItem>
    </Expand>
  </Type>

  <!-- TSet visualizer -->
  <Type Name="TSet&lt;*,*,*&gt;">
    <DisplayString Condition="Elements.Data.ArrayNum - Elements.NumFreeIndices &lt;= 0">Empty</DisplayString>
    <DisplayString Condition="Elements.Data.ArrayNum &lt;= Elements.Data.ArrayMax">Num={Elements.Data.ArrayNum - Elements.NumFreeIndices}</DisplayString>
    <Expand>
      <CustomListItems Condition="Elements.Data.ArrayNum - Elements.NumFreeIndices &gt; 0 &amp;&amp; Elements.Data.ArrayNum &lt;= Elements.Data.ArrayMax">
        <Variable Name="Index" InitialValue="0" />
        <Size>Elements.Data.ArrayNum - Elements.NumFreeIndices</Size>
        <Loop>
          <If Condition="
                 ((Elements.AllocationFlags.AllocatorInstance.SecondaryData.Data != 0) &amp;&amp; ((reinterpret_cast&lt;uint32*&gt;(Elements.AllocationFlags.AllocatorInstance.SecondaryData.Data)[Index/32]&gt;&gt;(Index%32)) &amp; 1) != 0)
              || ((Elements.AllocationFlags.AllocatorInstance.SecondaryData.Data == 0) &amp;&amp; ((reinterpret_cast&lt;uint32*&gt;(Elements.AllocationFlags.AllocatorInstance.InlineData        )[Index/32]&gt;&gt;(Index%32)) &amp; 1) != 0)
          ">
            <Item>((TSetElement &lt;$T1&gt; *)Elements.Data.AllocatorInstance.Data)[Index].Value</Item>
          </If>
          <Exec>++Index</Exec>
        </Loop>
      </CustomListItems>
    </Expand>
  </Type>

  <!-- TSet<*,*,TInlineSetAllocator<*>> visualizer -->
  <Type Name="TSet&lt;*,*,TInlineSetAllocator&lt;*&gt;&gt;">
    <DisplayString Condition="Elements.Data.ArrayNum - Elements.NumFreeIndices &lt;= 0">Empty</DisplayString>
    <DisplayString Condition="Elements.Data.ArrayNum &lt;= Elements.Data.ArrayMax">Num={Elements.Data.ArrayNum - Elements.NumFreeIndices}</DisplayString>
    <Expand>
      <CustomListItems Condition="Elements.Data.ArrayNum - Elements.NumFreeIndices &gt; 0 &amp;&amp; Elements.Data.ArrayNum &lt;= Elements.Data.ArrayMax">
        <Variable Name="Index" InitialValue="0" />
        <Size>Elements.Data.ArrayNum - Elements.NumFreeIndices</Size>
        <Loop>
          <If Condition="
                 ((Elements.AllocationFlags.AllocatorInstance.SecondaryData.Data != 0) &amp;&amp; ((reinterpret_cast&lt;uint32*&gt;(Elements.AllocationFlags.AllocatorInstance.SecondaryData.Data)[Index/32]&gt;&gt;(Index%32)) &amp; 1) != 0)
              || ((Elements.AllocationFlags.AllocatorInstance.SecondaryData.Data == 0) &amp;&amp; ((reinterpret_cast&lt;uint32*&gt;(Elements.AllocationFlags.AllocatorInstance.InlineData        )[Index/32]&gt;&gt;(Index%32)) &amp; 1) != 0)
          ">
            <If Condition="Elements.Data.AllocatorInstance.SecondaryData.Data == 0">
              <Item>((TSetElement&lt;$T1&gt; *)Elements.Data.AllocatorInstance.InlineData)[Index].Value</Item>
            </If>
            <If Condition="Elements.Data.AllocatorInstance.SecondaryData.Data != 0">
              <Item>((TSetElement&lt;$T1&gt; *)Elements.Data.AllocatorInstance.SecondaryData.Data)[Index].Value</Item>
            </If>
          </If>
          <Exec>++Index</Exec>
        </Loop>
      </CustomListItems>
    </Expand>
  </Type>

  <!-- TSet<*,*,TFixedSetAllocator<*>> visualizer -->
  <Type Name="TSet&lt;*,*,TFixedSetAllocator&lt;*&gt;&gt;">
    <DisplayString Condition="Elements.Data.ArrayNum - Elements.NumFreeIndices &lt;= 0">Empty</DisplayString>
    <DisplayString Condition="Elements.Data.ArrayNum &lt;= Elements.Data.ArrayMax">Num={Elements.Data.ArrayNum - Elements.NumFreeIndices}</DisplayString>
    <Expand>
      <CustomListItems Condition="Elements.Data.ArrayNum - Elements.NumFreeIndices &gt; 0 &amp;&amp; Elements.Data.ArrayNum &lt;= Elements.Data.ArrayMax">
        <Variable Name="Index" InitialValue="0" />
        <Size>Elements.Data.ArrayNum - Elements.NumFreeIndices</Size>
        <Loop>
          <If Condition="((reinterpret_cast&lt;uint32*&gt;(Elements.AllocationFlags.AllocatorInstance.InlineData)[Index/32]&gt;&gt;(Index%32)) &amp; 1) != 0">
            <Item>((TSetElement&lt;$T1&gt; *)Elements.Data.AllocatorInstance.InlineData)[Index].Value</Item>
          </If>
          <Exec>++Index</Exec>
        </Loop>
      </CustomListItems>
    </Expand>
  </Type>

  <!-- FWeakObjectPtr visualizer -->
  <Type Name="FWeakObjectPtr">
    <DisplayString Condition="ObjectSerialNumber &lt; 1">nullptr</DisplayString>
    <DisplayString Condition="GObjectArrayForDebugVisualizers->Objects[ObjectIndex / 65536][ObjectIndex % 65536].SerialNumber != ObjectSerialNumber">STALE</DisplayString>
    <DisplayString>{GObjectArrayForDebugVisualizers->Objects[ObjectIndex / 65536][ObjectIndex % 65536].Object}</DisplayString>
    <Expand>
      <ExpandedItem>GObjectArrayForDebugVisualizers->Objects[ObjectIndex / 65536][ObjectIndex % 65536].Object</ExpandedItem>
    </Expand>
  </Type>

  <!-- TWeakObjectPtr<*> visualizer -->
  <Type Name="TWeakObjectPtr&lt;*&gt;">
    <DisplayString Condition="ObjectSerialNumber &lt; 1">nullptr</DisplayString>
    <DisplayString Condition="GObjectArrayForDebugVisualizers->Objects[ObjectIndex / 65536][ObjectIndex % 65536].SerialNumber != ObjectSerialNumber">STALE</DisplayString>
    <DisplayString>{($T1*)GObjectArrayForDebugVisualizers->Objects[ObjectIndex / 65536][ObjectIndex % 65536].Object}</DisplayString>
    <Expand>
      <ExpandedItem>($T1*)GObjectArrayForDebugVisualizers->Objects[ObjectIndex / 65536][ObjectIndex % 65536].Object</ExpandedItem>
    </Expand>
  </Type>

  <!-- FSubobjectPtr visualizer -->
  <Type Name="FSubobjectPtr">
    <DisplayString>{Object}</DisplayString>
  </Type>

  <!-- FVertexID visualizer -->
  <Type Name="FVertexID">
    <DisplayString>{IDValue}</DisplayString>
  </Type>

  <!-- FVertexInstanceID visualizer -->
  <Type Name="FVertexInstanceID">
    <DisplayString>{IDValue}</DisplayString>
  </Type>

  <!-- FEdgeID visualizer -->
  <Type Name="FEdgeID">
    <DisplayString>{IDValue}</DisplayString>
  </Type>

  <!-- FPolygonID visualizer -->
  <Type Name="FPolygonID">
    <DisplayString>{IDValue}</DisplayString>
  </Type>

  <!-- FPolygonGroupID visualizer -->
  <Type Name="FPolygonGroupID">
    <DisplayString>{IDValue}</DisplayString>
  </Type>

  <!-- FTriangleID visualizer -->
  <Type Name="FTriangleID">
    <DisplayString>{IDValue}</DisplayString>
  </Type>

  <!-- TOptional visualizer -->
  <Type Name="TOptional&lt;*&gt;">
    <DisplayString Condition="!bIsSet">Unset</DisplayString>
    <DisplayString Condition="bIsSet">Set: {{{*($T1*)&amp;Value}}}</DisplayString>
    <Expand>
      <ExpandedItem Condition="bIsSet">*($T1*)&amp;Value</ExpandedItem>
    </Expand>
  </Type>

  <!-- TUnion visualizer -->
  <Type Name="TUnion&lt;*&gt;">
    <DisplayString>TUnion{{{CurrentSubtypeIndex}}}</DisplayString>
    <Expand>
      <Item Name="[TUnion.CurrentSubtypeIndex]">CurrentSubtypeIndex</Item>
      <ExpandedItem Condition="CurrentSubtypeIndex==0">*($T1*)&amp;Values.A</ExpandedItem>
      <ExpandedItem Condition="CurrentSubtypeIndex==1">*($T2*)&amp;Values.B</ExpandedItem>
      <ExpandedItem Condition="CurrentSubtypeIndex==2">*($T3*)&amp;Values.C</ExpandedItem>
      <ExpandedItem Condition="CurrentSubtypeIndex==3">*($T4*)&amp;Values.D</ExpandedItem>
      <ExpandedItem Condition="CurrentSubtypeIndex==4">*($T5*)&amp;Values.E</ExpandedItem>
      <ExpandedItem Condition="CurrentSubtypeIndex==5">*($T6*)&amp;Values.F</ExpandedItem>
    </Expand>
  </Type>

  <!-- TInlineValue visualizer -->
  <Type Name="TInlineValue&lt;*&gt;">
    <DisplayString Condition="!bIsValid">Null</DisplayString>
    <DisplayString Condition="bIsValid &amp;&amp; bInline">{{{*($T1*)&amp;Data}}}</DisplayString>
    <DisplayString Condition="bIsValid &amp;&amp; !bInline">{{{**(($T1**)&amp;Data)}}}</DisplayString>
    <Expand>
      <ExpandedItem Condition="bIsValid &amp;&amp; bInline">*($T1*)&amp;Data</ExpandedItem>
      <ExpandedItem Condition="bIsValid &amp;&amp; !bInline">**(($T1**)&amp;Data)</ExpandedItem>
    </Expand>
  </Type>

  <!-- TFunction visualizer -->
  <Type Name="UE4Function_Private::TDebugHelper&lt;*&gt;">
    <DisplayString>{*Ptr}</DisplayString>
    <Expand>
      <Item Name="[Lambda]">*Ptr</Item>
    </Expand>
  </Type>
  <Type Name="TFunctionRef&lt;*&gt;">
    <DisplayString Condition="Callable">{DebugPtrStorage}</DisplayString>
    <DisplayString Condition="!Callable">Unset</DisplayString>
    <Expand>
      <ExpandedItem Condition="Callable">DebugPtrStorage</ExpandedItem>
    </Expand>
  </Type>
  <Type Name="TFunction&lt;*&gt;">
    <AlternativeType Name="TUniqueFunction&lt;*&gt;"></AlternativeType>
    <DisplayString Condition="Callable != 0">{DebugPtrStorage}</DisplayString>
    <DisplayString Condition="Callable == 0">Unset</DisplayString>
    <Expand>
      <ExpandedItem Condition="Callable != 0">DebugPtrStorage</ExpandedItem>
    </Expand>
  </Type>

  <!-- FGameplayTagContainer visualizer -->
  <Type Name="FGameplayTagContainer">
    <DisplayString Condition="GameplayTags.ArrayNum == 0">Empty</DisplayString>
    <DisplayString Condition="GameplayTags.ArrayNum == 1">Tag={*((FName*)(GameplayTags.AllocatorInstance.Data))}</DisplayString>
    <DisplayString Condition="GameplayTags.ArrayNum > 1">Num={GameplayTags.ArrayNum}</DisplayString>
    <Expand>
      <ArrayItems Condition="GameplayTags.ArrayNum &lt;= GameplayTags.ArrayMax">
        <Size>GameplayTags.ArrayNum</Size>
        <ValuePointer>((FName*)(GameplayTags.AllocatorInstance.Data))</ValuePointer>
      </ArrayItems>
    </Expand>
  </Type>

  <!-- FActorRepList visualizer -->
  <Type Name="FActorRepList">
    <DisplayString >({Num}/{Max} {RefCount})</DisplayString>
    <Expand>
      <Item Name="[RefCount]">RefCount</Item>
      <Item Name="[Num]">Num</Item>
      <Item Name="[Max]">Max</Item>
      <ArrayItems>
        <Size>Num</Size>
        <ValuePointer>((FActorRepListType*)(Data))</ValuePointer>
      </ArrayItems>
    </Expand>
  </Type>

  <!-- TTuple visualizer -->
  <Type Name="TTuple&lt;&gt;">
    <DisplayString>{{}}</DisplayString>
    <Expand>
    </Expand>
  </Type>
  <Type Name="TTuple&lt;*&gt;">
    <DisplayString>{{{(*(UE4Tuple_Private::TTupleBaseElement&lt;$T1,0,1&gt;*)this).Value}}}</DisplayString>
    <Expand>
      <Item Name="[0]">((UE4Tuple_Private::TTupleBaseElement&lt;$T1,0,1&gt;*)this)->Value</Item>
    </Expand>
  </Type>
  <Type Name="TTuple&lt;*,*&gt;">
    <DisplayString>{{{Key},{Value}}}</DisplayString>
    <Expand>
      <Item Name="[0:Key]">Key</Item>
      <Item Name="[1:Value]">Value</Item>
    </Expand>
  </Type>
  <Type Name="TTuple&lt;*,*,*&gt;">
    <DisplayString>{{{(*(UE4Tuple_Private::TTupleBaseElement&lt;$T1,0,3&gt;*)this).Value},{(*(UE4Tuple_Private::TTupleBaseElement&lt;$T2,1,3&gt;*)this).Value},{(*(UE4Tuple_Private::TTupleBaseElement&lt;$T3,2,3&gt;*)this).Value}}}</DisplayString>
    <Expand>
      <Item Name="[0]">((UE4Tuple_Private::TTupleBaseElement&lt;$T1,0,3&gt;*)this)->Value</Item>
      <Item Name="[1]">((UE4Tuple_Private::TTupleBaseElement&lt;$T2,1,3&gt;*)this)->Value</Item>
      <Item Name="[2]">((UE4Tuple_Private::TTupleBaseElement&lt;$T3,2,3&gt;*)this)->Value</Item>
    </Expand>
  </Type>
  <Type Name="TTuple&lt;*,*,*,*&gt;">
    <DisplayString>{{{(*(UE4Tuple_Private::TTupleBaseElement&lt;$T1,0,4&gt;*)this).Value},{(*(UE4Tuple_Private::TTupleBaseElement&lt;$T2,1,4&gt;*)this).Value},{(*(UE4Tuple_Private::TTupleBaseElement&lt;$T3,2,4&gt;*)this).Value},{(*(UE4Tuple_Private::TTupleBaseElement&lt;$T4,3,4&gt;*)this).Value}}}</DisplayString>
    <Expand>
      <Item Name="[0]">((UE4Tuple_Private::TTupleBaseElement&lt;$T1,0,4&gt;*)this)->Value</Item>
      <Item Name="[1]">((UE4Tuple_Private::TTupleBaseElement&lt;$T2,1,4&gt;*)this)->Value</Item>
      <Item Name="[2]">((UE4Tuple_Private::TTupleBaseElement&lt;$T3,2,4&gt;*)this)->Value</Item>
      <Item Name="[3]">((UE4Tuple_Private::TTupleBaseElement&lt;$T4,3,4&gt;*)this)->Value</Item>
    </Expand>
  </Type>
  <Type Name="TTuple&lt;*,*,*,*,*&gt;">
    <DisplayString>{{{(*(UE4Tuple_Private::TTupleBaseElement&lt;$T1,0,5&gt;*)this).Value},{(*(UE4Tuple_Private::TTupleBaseElement&lt;$T2,1,5&gt;*)this).Value},{(*(UE4Tuple_Private::TTupleBaseElement&lt;$T3,2,5&gt;*)this).Value},{(*(UE4Tuple_Private::TTupleBaseElement&lt;$T4,3,5&gt;*)this).Value},{(*(UE4Tuple_Private::TTupleBaseElement&lt;$T5,4,5&gt;*)this).Value}}}</DisplayString>
    <Expand>
      <Item Name="[0]">((UE4Tuple_Private::TTupleBaseElement&lt;$T1,0,5&gt;*)this)->Value</Item>
      <Item Name="[1]">((UE4Tuple_Private::TTupleBaseElement&lt;$T2,1,5&gt;*)this)->Value</Item>
      <Item Name="[2]">((UE4Tuple_Private::TTupleBaseElement&lt;$T3,2,5&gt;*)this)->Value</Item>
      <Item Name="[3]">((UE4Tuple_Private::TTupleBaseElement&lt;$T4,3,5&gt;*)this)->Value</Item>
      <Item Name="[4]">((UE4Tuple_Private::TTupleBaseElement&lt;$T5,4,5&gt;*)this)->Value</Item>
    </Expand>
  </Type>
  <Type Name="TTuple&lt;*,*,*,*,*,*&gt;">
    <DisplayString>{{{(*(UE4Tuple_Private::TTupleBaseElement&lt;$T1,0,6&gt;*)this).Value},{(*(UE4Tuple_Private::TTupleBaseElement&lt;$T2,1,6&gt;*)this).Value},{(*(UE4Tuple_Private::TTupleBaseElement&lt;$T3,2,6&gt;*)this).Value},{(*(UE4Tuple_Private::TTupleBaseElement&lt;$T4,3,6&gt;*)this).Value},{(*(UE4Tuple_Private::TTupleBaseElement&lt;$T5,4,6&gt;*)this).Value},{(*(UE4Tuple_Private::TTupleBaseElement&lt;$T6,5,6&gt;*)this).Value}}}</DisplayString>
    <Expand>
      <Item Name="[0]">((UE4Tuple_Private::TTupleBaseElement&lt;$T1,0,6&gt;*)this)->Value</Item>
      <Item Name="[1]">((UE4Tuple_Private::TTupleBaseElement&lt;$T2,1,6&gt;*)this)->Value</Item>
      <Item Name="[2]">((UE4Tuple_Private::TTupleBaseElement&lt;$T3,2,6&gt;*)this)->Value</Item>
      <Item Name="[3]">((UE4Tuple_Private::TTupleBaseElement&lt;$T4,3,6&gt;*)this)->Value</Item>
      <Item Name="[4]">((UE4Tuple_Private::TTupleBaseElement&lt;$T5,4,6&gt;*)this)->Value</Item>
      <Item Name="[5]">((UE4Tuple_Private::TTupleBaseElement&lt;$T6,5,6&gt;*)this)->Value</Item>
    </Expand>
  </Type>
  <Type Name="TTuple&lt;*,*,*,*,*,*,*&gt;">
    <DisplayString>{{{(*(UE4Tuple_Private::TTupleBaseElement&lt;$T1,0,7&gt;*)this).Value},{(*(UE4Tuple_Private::TTupleBaseElement&lt;$T2,1,7&gt;*)this).Value},{(*(UE4Tuple_Private::TTupleBaseElement&lt;$T3,2,7&gt;*)this).Value},{(*(UE4Tuple_Private::TTupleBaseElement&lt;$T4,3,7&gt;*)this).Value},{(*(UE4Tuple_Private::TTupleBaseElement&lt;$T5,4,7&gt;*)this).Value},{(*(UE4Tuple_Private::TTupleBaseElement&lt;$T6,5,7&gt;*)this).Value},{(*(UE4Tuple_Private::TTupleBaseElement&lt;$T7,6,7&gt;*)this).Value}}}</DisplayString>
    <Expand>
      <Item Name="[0]">((UE4Tuple_Private::TTupleBaseElement&lt;$T1,0,7&gt;*)this)->Value</Item>
      <Item Name="[1]">((UE4Tuple_Private::TTupleBaseElement&lt;$T2,1,7&gt;*)this)->Value</Item>
      <Item Name="[2]">((UE4Tuple_Private::TTupleBaseElement&lt;$T3,2,7&gt;*)this)->Value</Item>
      <Item Name="[3]">((UE4Tuple_Private::TTupleBaseElement&lt;$T4,3,7&gt;*)this)->Value</Item>
      <Item Name="[4]">((UE4Tuple_Private::TTupleBaseElement&lt;$T5,4,7&gt;*)this)->Value</Item>
      <Item Name="[5]">((UE4Tuple_Private::TTupleBaseElement&lt;$T6,5,7&gt;*)this)->Value</Item>
      <Item Name="[6]">((UE4Tuple_Private::TTupleBaseElement&lt;$T7,6,7&gt;*)this)->Value</Item>
    </Expand>
  </Type>

  <!-- TDelegateBase visualizer -->
  <Type Name="TBaseStaticDelegateInstance&lt;*&gt;">
    <DisplayString>{StaticFuncPtr}</DisplayString>
    <Expand>
      <Item Name="[StaticFuncPtr]">StaticFuncPtr</Item>
      <Item Name="[Payload]">Payload</Item>
      <Item Name="[Handle]">Handle</Item>
    </Expand>
  </Type>
  <Type Name="TBaseFunctorDelegateInstance&lt;*&gt;">
    <DisplayString>{Functor}</DisplayString>
    <Expand>
      <Item Name="[Functor]">Functor</Item>
      <Item Name="[Payload]">Payload</Item>
      <Item Name="[Handle]">Handle</Item>
    </Expand>
  </Type>
  <Type Name="TBaseRawMethodDelegateInstance&lt;*,*,*&gt;">
    <DisplayString>{UserObject}</DisplayString>
    <Expand>
      <Item Name="[UserObject]">UserObject</Item>
      <Item Name="[MethodPtr]">MethodPtr</Item>
      <Item Name="[Payload]">Payload</Item>
      <Item Name="[Handle]">Handle</Item>
    </Expand>
  </Type>
  <Type Name="TBaseSPMethodDelegateInstance&lt;*,*,*&gt;">
    <DisplayString>{UserObject}</DisplayString>
    <Expand>
      <Item Name="[UserObject]">UserObject</Item>
      <Item Name="[MethodPtr]">MethodPtr</Item>
      <Item Name="[Payload]">Payload</Item>
      <Item Name="[Handle]">Handle</Item>
    </Expand>
  </Type>
  <Type Name="TBaseUObjectMethodDelegateInstance&lt;*,*,*&gt;">
    <DisplayString>{UserObject}</DisplayString>
    <Expand>
      <Item Name="[UserObject]">UserObject</Item>
      <Item Name="[MethodPtr]">MethodPtr</Item>
      <Item Name="[Payload]">Payload</Item>
      <Item Name="[Handle]">Handle</Item>
    </Expand>
  </Type>
  <Type Name="TBaseUFunctionDelegateInstance&lt;*,*&gt;">
    <DisplayString>{UserObjectPtr}</DisplayString>
    <Expand>
      <Item Name="[UserObject]">UserObjectPtr</Item>
      <Item Name="[FunctionName]">FunctionName</Item>
      <Item Name="[Payload]">Payload</Item>
      <Item Name="[Handle]">Handle</Item>
    </Expand>
  </Type>
  <Type Name="TDelegateBase&lt;*&gt;" Priority="MediumLow">
    <DisplayString Condition="DelegateSize == 0">Unbound</DisplayString>
    <DisplayString Condition="DelegateSize &lt;= 2">{*((IDelegateInstance*)(DelegateAllocator.InlineData))}</DisplayString>
    <DisplayString Condition="DelegateSize &gt; 2">{*((IDelegateInstance*)(DelegateAllocator.SecondaryData.Data))}</DisplayString>
    <Expand>
      <ExpandedItem Condition="DelegateSize == 0">DelegateAllocator</ExpandedItem>
      <ExpandedItem Condition="DelegateSize &lt;= 2">*((IDelegateInstance*)(DelegateAllocator.InlineData))</ExpandedItem>
      <ExpandedItem Condition="DelegateSize &gt; 2">*((IDelegateInstance*)(DelegateAllocator.SecondaryData.Data))</ExpandedItem>
    </Expand>
  </Type>
  <Type Name="TDelegateBase&lt;*&gt;">
    <DisplayString Condition="DelegateSize == 0">Unbound</DisplayString>
    <DisplayString Condition="DelegateSize != 0">{*((IDelegateInstance*)(DelegateAllocator.Data))}</DisplayString>
    <Expand>
      <ExpandedItem Condition="DelegateSize == 0">DelegateAllocator</ExpandedItem>
      <ExpandedItem Condition="DelegateSize != 0">*((IDelegateInstance*)(DelegateAllocator.Data))</ExpandedItem>
    </Expand>
  </Type>
  <Type Name="TMulticastDelegate&lt;*,*&gt;" Priority="MediumLow">
    <DisplayString Condition="InvocationList.ArrayNum == 0">Empty</DisplayString>
    <DisplayString Condition="InvocationList.ArrayNum != 0">Num={InvocationList.ArrayNum}</DisplayString>
    <Expand>
      <ArrayItems>
        <Size>InvocationList.ArrayNum</Size>
        <ValuePointer Condition="InvocationList.AllocatorInstance.SecondaryData.Data == 0">(TDelegateBase&lt;$T2&gt;*)(InvocationList.AllocatorInstance.InlineData)</ValuePointer>
        <ValuePointer Condition="InvocationList.AllocatorInstance.SecondaryData.Data != 0">(TDelegateBase&lt;$T2&gt;*)(InvocationList.AllocatorInstance.SecondaryData.Data)</ValuePointer>
      </ArrayItems>
    </Expand>
  </Type>
  <Type Name="TMulticastDelegate&lt;*,*&gt;">
    <DisplayString Condition="InvocationList.ArrayNum == 0">Empty</DisplayString>
    <DisplayString Condition="InvocationList.ArrayNum != 0">Num={InvocationList.ArrayNum}</DisplayString>
    <Expand>
      <ArrayItems>
        <Size>InvocationList.ArrayNum</Size>
        <ValuePointer>(TDelegateBase&lt;$T2&gt;*)(InvocationList.AllocatorInstance.Data)</ValuePointer>
      </ArrayItems>
    </Expand>
  </Type>

  <!-- TRange visualizer -->
  <Type Name="TAtomic&lt;*&gt;">
    <DisplayString>{Element}</DisplayString>
    <Expand>
      <ExpandedItem>Element</ExpandedItem>
    </Expand>
  </Type>

  <!-- TRange visualizer -->
  <Type Name="TRange&lt;*&gt;">
    <DisplayString Condition="LowerBound.Type.Value == ERangeBoundTypes::Open &amp;&amp; UpperBound.Type.Value == ERangeBoundTypes::Open">[-&#8734;, +&#8734;]</DisplayString>
    <DisplayString Condition="LowerBound.Type.Value == ERangeBoundTypes::Open &amp;&amp; UpperBound.Type.Value == ERangeBoundTypes::Inclusive">[-&#8734;, {UpperBound.Value}]</DisplayString>
    <DisplayString Condition="LowerBound.Type.Value == ERangeBoundTypes::Open &amp;&amp; UpperBound.Type.Value == ERangeBoundTypes::Exclusive">[-&#8734;, {UpperBound.Value})</DisplayString>

    <DisplayString Condition="LowerBound.Type.Value == ERangeBoundTypes::Inclusive &amp;&amp; UpperBound.Type.Value == ERangeBoundTypes::Open">[{LowerBound.Value}, +&#8734;)</DisplayString>
    <DisplayString Condition="LowerBound.Type.Value == ERangeBoundTypes::Inclusive &amp;&amp; UpperBound.Type.Value == ERangeBoundTypes::Inclusive">[{LowerBound.Value}, {UpperBound.Value}]</DisplayString>
    <DisplayString Condition="LowerBound.Type.Value == ERangeBoundTypes::Inclusive &amp;&amp; UpperBound.Type.Value == ERangeBoundTypes::Exclusive">[{LowerBound.Value}, {UpperBound.Value})</DisplayString>

    <DisplayString Condition="LowerBound.Type.Value == ERangeBoundTypes::Exclusive &amp;&amp; UpperBound.Type.Value == ERangeBoundTypes::Open">({LowerBound.Value}, +&#8734;]</DisplayString>
    <DisplayString Condition="LowerBound.Type.Value == ERangeBoundTypes::Exclusive &amp;&amp; UpperBound.Type.Value == ERangeBoundTypes::Inclusive">({LowerBound.Value}, {UpperBound.Value}]</DisplayString>
    <DisplayString Condition="LowerBound.Type.Value == ERangeBoundTypes::Exclusive &amp;&amp; UpperBound.Type.Value == ERangeBoundTypes::Exclusive">({LowerBound.Value}, {UpperBound.Value})</DisplayString>
  </Type>

  <!-- FFrameNumber visualizer -->
  <Type Name="FFrameNumber">
    <DisplayString>{Value}</DisplayString>
  </Type>

  <!-- FFrameTime visualizer -->
  <Type Name="FFrameTime">
    <DisplayString Condition="SubFrame == 0.0">{FrameNumber}</DisplayString>
    <DisplayString Condition="SubFrame != 0.0">{(double)(FrameNumber.Value)+SubFrame}</DisplayString>
  </Type>

  <!-- FRHICommandList visualizer -->
  <Type Name="FRHICommandBase">
    <DisplayString>{{ RHI Command -> { this->__vfptr[0] } }}</DisplayString>
  </Type>

  <Type Name="FRHICommandList">
    <Expand>
      <LinkedListItems>
        <HeadPointer>Root</HeadPointer>
        <NextPointer>Next</NextPointer>
        <ValueNode>this</ValueNode>
      </LinkedListItems>
    </Expand>
  </Type>
	
	<!-- TVariant visualizer -->
	<Type Name="TVariant&lt;*&gt;">
		<DisplayString Condition="TypeIndex == 0">{*($T1*)&amp;Storage}</DisplayString>
		<DisplayString>Uninitialized</DisplayString>
		<Expand>
			<Item Name="Storage" Condition="TypeIndex == 0">*($T1*)&amp;Storage</Item>
			<Item Name="TypeIndex">TypeIndex</Item>
		</Expand>
	</Type>
	<Type Name="TVariant&lt;*,*&gt;">
		<DisplayString Condition="TypeIndex == 0">{*($T1*)&amp;Storage}</DisplayString>
		<DisplayString Condition="TypeIndex == 1">{*($T2*)&amp;Storage}</DisplayString>
		<DisplayString>Uninitialized</DisplayString>
		<Expand>
			<Item Name="Storage" Condition="TypeIndex == 0">*($T1*)&amp;Storage</Item>
			<Item Name="Storage" Condition="TypeIndex == 1">*($T2*)&amp;Storage</Item>
			<Item Name="TypeIndex">TypeIndex</Item>
		</Expand>
	</Type>
	<Type Name="TVariant&lt;*,*,*&gt;">
		<DisplayString Condition="TypeIndex == 0">{*($T1*)&amp;Storage}</DisplayString>
		<DisplayString Condition="TypeIndex == 1">{*($T2*)&amp;Storage}</DisplayString>
		<DisplayString Condition="TypeIndex == 2">{*($T3*)&amp;Storage}</DisplayString>
		<DisplayString>Uninitialized</DisplayString>
		<Expand>
			<Item Name="Storage" Condition="TypeIndex == 0">*($T1*)&amp;Storage</Item>
			<Item Name="Storage" Condition="TypeIndex == 1">*($T2*)&amp;Storage</Item>
			<Item Name="Storage" Condition="TypeIndex == 2">*($T3*)&amp;Storage</Item>
			<Item Name="TypeIndex">TypeIndex</Item>
		</Expand>
	</Type>
	<Type Name="TVariant&lt;*,*,*,*&gt;">
		<DisplayString Condition="TypeIndex == 0">{*($T1*)&amp;Storage}</DisplayString>
		<DisplayString Condition="TypeIndex == 1">{*($T2*)&amp;Storage}</DisplayString>
		<DisplayString Condition="TypeIndex == 2">{*($T3*)&amp;Storage}</DisplayString>
		<DisplayString Condition="TypeIndex == 3">{*($T4*)&amp;Storage}</DisplayString>
		<DisplayString>Uninitialized</DisplayString>
		<Expand>
			<Item Name="Storage" Condition="TypeIndex == 0">*($T1*)&amp;Storage</Item>
			<Item Name="Storage" Condition="TypeIndex == 1">*($T2*)&amp;Storage</Item>
			<Item Name="Storage" Condition="TypeIndex == 2">*($T3*)&amp;Storage</Item>
			<Item Name="Storage" Condition="TypeIndex == 3">*($T4*)&amp;Storage</Item>
			<Item Name="TypeIndex">TypeIndex</Item>
		</Expand>
	</Type>
	<Type Name="TVariant&lt;*,*,*,*,*&gt;">
		<DisplayString Condition="TypeIndex == 0">{*($T1*)&amp;Storage}</DisplayString>
		<DisplayString Condition="TypeIndex == 1">{*($T2*)&amp;Storage}</DisplayString>
		<DisplayString Condition="TypeIndex == 2">{*($T3*)&amp;Storage}</DisplayString>
		<DisplayString Condition="TypeIndex == 3">{*($T4*)&amp;Storage}</DisplayString>
		<DisplayString Condition="TypeIndex == 4">{*($T5*)&amp;Storage}</DisplayString>
		<DisplayString>Uninitialized</DisplayString>
		<Expand>
			<Item Name="Storage" Condition="TypeIndex == 0">*($T1*)&amp;Storage</Item>
			<Item Name="Storage" Condition="TypeIndex == 1">*($T2*)&amp;Storage</Item>
			<Item Name="Storage" Condition="TypeIndex == 2">*($T3*)&amp;Storage</Item>
			<Item Name="Storage" Condition="TypeIndex == 3">*($T4*)&amp;Storage</Item>
			<Item Name="Storage" Condition="TypeIndex == 4">*($T5*)&amp;Storage</Item>
			<Item Name="TypeIndex">TypeIndex</Item>
		</Expand>
	</Type>
	<Type Name="TVariant&lt;*,*,*,*,*,*&gt;">
		<DisplayString Condition="TypeIndex == 0">{*($T1*)&amp;Storage}</DisplayString>
		<DisplayString Condition="TypeIndex == 1">{*($T2*)&amp;Storage}</DisplayString>
		<DisplayString Condition="TypeIndex == 2">{*($T3*)&amp;Storage}</DisplayString>
		<DisplayString Condition="TypeIndex == 3">{*($T4*)&amp;Storage}</DisplayString>
		<DisplayString Condition="TypeIndex == 4">{*($T5*)&amp;Storage}</DisplayString>
		<DisplayString Condition="TypeIndex == 5">{*($T6*)&amp;Storage}</DisplayString>
		<DisplayString>Uninitialized</DisplayString>
		<Expand>
			<Item Name="Storage" Condition="TypeIndex == 0">*($T1*)&amp;Storage</Item>
			<Item Name="Storage" Condition="TypeIndex == 1">*($T2*)&amp;Storage</Item>
			<Item Name="Storage" Condition="TypeIndex == 2">*($T3*)&amp;Storage</Item>
			<Item Name="Storage" Condition="TypeIndex == 3">*($T4*)&amp;Storage</Item>
			<Item Name="Storage" Condition="TypeIndex == 4">*($T5*)&amp;Storage</Item>
			<Item Name="Storage" Condition="TypeIndex == 5">*($T6*)&amp;Storage</Item>
			<Item Name="TypeIndex">TypeIndex</Item>
		</Expand>
	</Type>
	<Type Name="TVariant&lt;*,*,*,*,*,*,*&gt;">
		<DisplayString Condition="TypeIndex == 0">{*($T1*)&amp;Storage}</DisplayString>
		<DisplayString Condition="TypeIndex == 1">{*($T2*)&amp;Storage}</DisplayString>
		<DisplayString Condition="TypeIndex == 2">{*($T3*)&amp;Storage}</DisplayString>
		<DisplayString Condition="TypeIndex == 3">{*($T4*)&amp;Storage}</DisplayString>
		<DisplayString Condition="TypeIndex == 4">{*($T5*)&amp;Storage}</DisplayString>
		<DisplayString Condition="TypeIndex == 5">{*($T6*)&amp;Storage}</DisplayString>
		<DisplayString Condition="TypeIndex == 6">{*($T7*)&amp;Storage}</DisplayString>
		<DisplayString>Uninitialized</DisplayString>
		<Expand>
			<Item Name="Storage" Condition="TypeIndex == 0">*($T1*)&amp;Storage</Item>
			<Item Name="Storage" Condition="TypeIndex == 1">*($T2*)&amp;Storage</Item>
			<Item Name="Storage" Condition="TypeIndex == 2">*($T3*)&amp;Storage</Item>
			<Item Name="Storage" Condition="TypeIndex == 3">*($T4*)&amp;Storage</Item>
			<Item Name="Storage" Condition="TypeIndex == 4">*($T5*)&amp;Storage</Item>
			<Item Name="Storage" Condition="TypeIndex == 5">*($T6*)&amp;Storage</Item>
			<Item Name="Storage" Condition="TypeIndex == 6">*($T7*)&amp;Storage</Item>
			<Item Name="TypeIndex">TypeIndex</Item>
		</Expand>
	</Type>
	<Type Name="TVariant&lt;*,*,*,*,*,*,*,*&gt;">
		<DisplayString Condition="TypeIndex == 0">{*($T1*)&amp;Storage}</DisplayString>
		<DisplayString Condition="TypeIndex == 1">{*($T2*)&amp;Storage}</DisplayString>
		<DisplayString Condition="TypeIndex == 2">{*($T3*)&amp;Storage}</DisplayString>
		<DisplayString Condition="TypeIndex == 3">{*($T4*)&amp;Storage}</DisplayString>
		<DisplayString Condition="TypeIndex == 4">{*($T5*)&amp;Storage}</DisplayString>
		<DisplayString Condition="TypeIndex == 5">{*($T6*)&amp;Storage}</DisplayString>
		<DisplayString Condition="TypeIndex == 6">{*($T7*)&amp;Storage}</DisplayString>
		<DisplayString Condition="TypeIndex == 7">{*($T8*)&amp;Storage}</DisplayString>
		<DisplayString>Uninitialized</DisplayString>
		<Expand>
			<Item Name="Storage" Condition="TypeIndex == 0">*($T1*)&amp;Storage</Item>
			<Item Name="Storage" Condition="TypeIndex == 1">*($T2*)&amp;Storage</Item>
			<Item Name="Storage" Condition="TypeIndex == 2">*($T3*)&amp;Storage</Item>
			<Item Name="Storage" Condition="TypeIndex == 3">*($T4*)&amp;Storage</Item>
			<Item Name="Storage" Condition="TypeIndex == 4">*($T5*)&amp;Storage</Item>
			<Item Name="Storage" Condition="TypeIndex == 5">*($T6*)&amp;Storage</Item>
			<Item Name="Storage" Condition="TypeIndex == 6">*($T7*)&amp;Storage</Item>
			<Item Name="Storage" Condition="TypeIndex == 7">*($T8*)&amp;Storage</Item>
			<Item Name="TypeIndex">TypeIndex</Item>
		</Expand>
	</Type>
  
  <!-- 
  *
  * Chaos Visualizers 
  *
  -->

  <!-- 2D TVector vizualizer -->
  <Type Name="Chaos::TVector&lt;int,2&gt;">
    <DisplayString>{{{X}, {Y}}}</DisplayString>
  </Type>
  <Type Name="Chaos::TVector&lt;float,2&gt;">
    <DisplayString>{{{X}, {Y}}}</DisplayString>
  </Type>

  <!-- 3D TVector vizualizer -->
  <Type Name="Chaos::TVector&lt;*,3&gt;">
    <DisplayString>{{{X}, {Y}, {Z}}}</DisplayString>
  </Type>
  
  <!-- 3D TRotation vizualizer -->
  <Type Name="Chaos::TRotation&lt;*,3&gt;">
    <DisplayString>{{{X}, {Y}, {Z}, {W}}}</DisplayString>
  </Type>

  <!-- 3D TRigidTransform vizualizer -->
  <Type Name="Chaos::TRigidTransform&lt;*,3&gt;">
    <Expand>
      <Item Name="Rotation">(Chaos::TRotation&lt;$T1,3&gt;&amp;)Rotation</Item>
      <Item Name="Translation">(Chaos::TVector&lt;$T1,3&gt;&amp;)Translation</Item>
      <Item Name="Scale3D">(Chaos::TVector&lt;$T1,3&gt;&amp;)Scale3D</Item>
    </Expand>
  </Type>

  <!-- 3x3 PMatrix visualizer. Just show diagonal elements in preview line. -->
  <Type Name="Chaos::PMatrix&lt;*,3,3&gt;">
    <DisplayString>{{{M[0][0]}, ..., {M[1][1]}, ..., {M[2][2]}}}</DisplayString>
  </Type>

  <!-- Chaos Particle Handle Vizualizer. Displays the elements from the SoA for the particle represented by the handle. -->
  <Type Name="Chaos::TGeometryParticleHandleImp&lt;*,*,*&gt;">
    <!-- non-transient handle -->
    <DisplayString Condition="$T3 == 1">&lt;{HandleIdx}&gt; @ {((Chaos::TVector&lt;$T1,$T2&gt;*)GeometryParticles->MX.AllocatorInstance.Data)[ParticleIdx]} ({Type})</DisplayString>
    <!-- transient handle -->
    <DisplayString Condition="$T3 == 0">&lt;T{((Chaos::TGeometryParticleHandleImp&lt;$T1,$T2,1&gt;**)GeometryParticles->MGeometryParticleHandle.AllocatorInstance.Data)[ParticleIdx]->HandleIdx}&gt; @ {((Chaos::TVector&lt;$T1,$T2&gt;*)GeometryParticles->MX.AllocatorInstance.Data)[ParticleIdx]} ({Type})</DisplayString>
    
    <Expand>
      <Item Condition="Type &gt;= 0" Name="Type">Type</Item>
      <Item Condition="Type &gt;= 0 &amp;&amp; $T3==1" Name="HandleIdx">HandleIdx</Item>
      <Item Condition="Type &gt;= 0" Name="UniqueIdx">((int32*)GeometryParticles->MUniqueIdx.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 0" Name="ParticleID">((int32*)GeometryParticles->MParticleIDs.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 0" Optional="true" Name="DebugName">((FName*)GeometryParticles->MDebugName.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 0" Name="X">((Chaos::TVector&lt;$T1,$T2&gt;*)GeometryParticles->MX.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 0" Name="R">((Chaos::TRotation&lt;$T1,$T2&gt;*)GeometryParticles->MR.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 0" Name="Geometry">((Chaos::TSerializablePtr&lt;Chaos::FImplicitObject&gt;*)GeometryParticles->MGeometry.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 0" Name="DynamicGeometry">((Chaos::TSerializablePtr&lt;Chaos::FImplicitObject&gt;*)GeometryParticles->MDynamicGeometry.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 0" Name="GeometryParticle">((Chaos::TGeometryParticle&lt;$T1,$T2&gt;**)GeometryParticles->MGeometryParticle.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 0" Name="ShapesArray">((Chaos::FShapesArray*)GeometryParticles->MShapesArray.AllocatorInstance.Data)[ParticleIdx]</Item>

      <Item Condition="Type &gt;= 1" Name="V">((Chaos::TVector&lt;$T1,$T2&gt;*)KinematicGeometryParticles->MV.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 1" Name="W">((Chaos::TVector&lt;$T1,$T2&gt;*)KinematicGeometryParticles->MW.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 1" Name="KinematicTarget">((Chaos::TKinematicTarget&lt;$T1,$T2&gt;*)KinematicGeometryParticles->KinematicTargets.AllocatorInstance.Data)[ParticleIdx]</Item>

      <Item Condition="Type &gt;= 2" Name="VSmooth">((Chaos::TVector&lt;$T1,$T2&gt;*)PBDRigidParticles->MVSmooth.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 2" Name="WSmooth">((Chaos::TVector&lt;$T1,$T2&gt;*)PBDRigidParticles->MWSmooth.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 2" Name="F">((Chaos::TVector&lt;$T1,$T2&gt;*)PBDRigidParticles->MF.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 2" Name="T">((Chaos::TVector&lt;$T1,$T2&gt;*)PBDRigidParticles->MT.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 2" Name="LinearImpulse">((Chaos::TVector&lt;$T1,$T2&gt;*)PBDRigidParticles->MLinearImpulse.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 2" Name="AngularImpulse">((Chaos::TVector&lt;$T1,$T2&gt;*)PBDRigidParticles->MAngularImpulse.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 2" Name="M">((float*)PBDRigidParticles->MM.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 2" Name="InvM">((float*)PBDRigidParticles->MInvM.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 2" Name="I">((Chaos::PMatrix&lt;$T1,$T2,3&gt;*)PBDRigidParticles->MI.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 2" Name="InvI">((Chaos::PMatrix&lt;$T1,$T2,3&gt;*)PBDRigidParticles->MInvI.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 2" Name="CenterOfMass">((Chaos::TVector&lt;$T1,$T2&gt;*)PBDRigidParticles->MCenterOfMass.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 2" Name="RotationOfMass">((Chaos::TRotation&lt;$T1,$T2&gt;*)PBDRigidParticles->MRotationOfMass.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 2" Name="CollisionParticles">((TUniquePtr&lt;Chaos::TBVHParticles&lt;$T1,$T2&gt;,TDefaultDelete&lt;Chaos::TBVHParticles&lt;$T1,$T2&gt; &gt; &gt;*)PBDRigidParticles->MCollisionParticles.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 2" Name="CollisionGroup">((int*)PBDRigidParticles->MCollisionGroup.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 2" Name="CollisionConstraintFlags">((int*)PBDRigidParticles->MCollisionConstraintFlags.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 2" Name="Island">((int*)PBDRigidParticles->MIsland.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 2" Name="Disabled">((bool*)PBDRigidParticles->MDisabled.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 2" Name="ToBeRemovedOnFracture">((bool*)PBDRigidParticles->MToBeRemovedOnFracture.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 2" Name="ObjectState">((enum Chaos::EObjectStateType*)PBDRigidParticles->MObjectState.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 2" Name="P">((Chaos::TVector&lt;$T1,$T2&gt;*)PBDRigidParticles->MP.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 2" Name="Q">((Chaos::TRotation&lt;$T1,$T2&gt;*)PBDRigidParticles->MQ.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 2" Name="PreV">((Chaos::TVector&lt;$T1,$T2&gt;*)PBDRigidParticles->MPreV.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 2" Name="PreW">((Chaos::TVector&lt;$T1,$T2&gt;*)PBDRigidParticles->MPreW.AllocatorInstance.Data)[ParticleIdx]</Item>
      <Item Condition="Type &gt;= 2" Name="GravityEnabled">((bool*)PBDRigidParticles->MGravityEnabled.AllocatorInstance.Data)[ParticleIdx]</Item>
    </Expand>
  </Type>

  <!-- Chaos Generic Particle Handle Vizualizer. Displays as a particle handle. -->
  <Type Name="Chaos::TGenericParticleHandle&lt;*,*&gt;">
    <DisplayString>&lt;{Imp.Handle->HandleIdx}&gt; @ {((Chaos::TVector&lt;$T1,$T2&gt;*)Imp.Handle->GeometryParticles->MX.AllocatorInstance.Data)[Imp.Handle->ParticleIdx]} ({Imp.Handle->Type})</DisplayString>
    <Expand>
      <ExpandedItem>Imp.Handle</ExpandedItem>
    </Expand>
  </Type>

  <!-- Chaos Kinematic Target Vizualizer. -->
  <Type Name="Chaos::TKinematicTarget&lt;*,*&gt;">
    <DisplayString>{Mode}</DisplayString>
    <Expand>
      <Item Condition="Mode &gt; 0" Name="Position">Target.Translation</Item>
      <Item Condition="Mode &gt; 0" Name="Rotation">Target.Rotation</Item>
    </Expand>
  </Type>

  <!-- Chaos Dense matrix visualizer. -->
  <Type Name="Chaos::TDenseMatrix&lt;*&gt;">
    <Expand>
      <ArrayItems>
        <Rank>2</Rank>
        <Size>$i == 0 ? NRows : NCols</Size>
        <ValuePointer>M</ValuePointer>
      </ArrayItems>
    </Expand>
  </Type>

  <!-- 
  Particles SoA vizualizer. This works by displaying the persistent handle for the particle which uses the above vizualizer.
  We are lucky we can do this - I don't think there's an easy way to vizualize SoAs in object order in natvis otherwise.
  -->
  <Type Name="Chaos::TGeometryParticlesImp&lt;*,*,*&gt;">
    <DisplayString Condition="MSize &lt;= 0">Empty</DisplayString>
    <DisplayString Condition="MSize &gt; 0">Size={MSize}</DisplayString>
    <Expand>
      <IndexListItems Condition="MSize &gt; 0">
        <Size>MSize</Size>
        <ValueNode>
          ((Chaos::TGeometryParticleHandleImp&lt;$T1,$T2,1&gt;**)MGeometryParticleHandle.AllocatorInstance.Data)[$i]
        </ValueNode>
      </IndexListItems>
    </Expand>
  </Type>

  <!-- Chaos Joint Handle Vizualizer. -->
  <Type Name="Chaos::FPBDJointConstraintHandle">
    <DisplayString>{ConstraintIndex}: {(((Chaos::FPBDJointState*)ConstraintContainer->ConstraintStates.AllocatorInstance.Data)[ConstraintIndex]).Level}</DisplayString>
    <Expand>
      <Item Name="ConstraintIndex">ConstraintIndex</Item>
      <Item Name="ConstraintParticles">((Chaos::FPBDJointConstraints::FParticlePair*)ConstraintContainer->ConstraintParticles.AllocatorInstance.Data)[ConstraintIndex]</Item>
      <Item Name="ConstraintSettings">((Chaos::FPBDJointSettings*)ConstraintContainer->ConstraintSettings.AllocatorInstance.Data)[ConstraintIndex]</Item>
      <Item Name="ConstraintState">((Chaos::FPBDJointState*)ConstraintContainer->ConstraintStates.AllocatorInstance.Data)[ConstraintIndex]</Item>
    </Expand>
  </Type>

  <!-- FIoChunkId visualizer -->
  <Type Name="FIoChunkId">
    <!-- Id is 12 bytes long and the object is considered Invalid if all values are 0 -->
    <DisplayString Condition="reinterpret_cast&lt;uint32*&gt;(Id)[0] == 0 &amp;&amp; reinterpret_cast&lt;uint32*&gt;(Id)[1] == 0 &amp;&amp; reinterpret_cast&lt;uint32*&gt;(Id)[2] == 0">Invalid</DisplayString>
    <Expand>
      <Item Name="ChunkId">*(uint64*)&amp;Id[0]</Item>
      <Item Name="ChunkIndex">*(uint16*)&amp;Id[8]</Item>
      <Item Name="EIoChunkType">*(EIoChunkType*)&amp;Id[11]</Item>
    </Expand>
  </Type>

  <!-- 
  *
  * Niagara Visualizers 
  *
  -->

  <!-- FNiagaraVariable visualizer -->
  <Type Name="FNiagaraVariableBase">
    <DisplayString>Name={Name}, Type={((FNiagaraTypeDefinition*)(FNiagaraTypeRegistry::RegisteredTypes.AllocatorInstance.InlineData))[TypeDefHandle.RegisteredTypeIndex].ClassStructOrEnum->NamePrivate}</DisplayString>
  </Type>

  <Type Name="UNiagaraNodeFunctionCall">
    <DisplayString>Name={NamePrivate}, FunctionName={FunctionDisplayName}</DisplayString>
  </Type>

</AutoVisualizer>
